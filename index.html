<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally</title>
<style>
  :root{
    --hud-bg: rgba(20,20,30,.55);
    --accent:#ffd34d;
    --ringP: rgba(255,235,150,.95);
    --ringO: rgba(170,220,255,.92);
  }
  html,body{margin:0;height:100%;background:#091427;color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Noto Sans JP",sans-serif}
  #cv{position:fixed;inset:0;touch-action:manipulation}
  /* HUD: 折り返しで切れ防止 */
  .hud{
    position:fixed;left:10px;right:10px;top:calc(10px + env(safe-area-inset-top,0px));
    display:flex;flex-wrap:wrap;gap:10px;z-index:5;pointer-events:none
  }
  .pill{
    flex:1 1 32%;min-width:160px;
    background:var(--hud-bg);backdrop-filter:blur(2px);
    border-radius:18px;padding:10px 14px;font-weight:800;letter-spacing:.2px
  }
  .pill b{display:block;font-size:18px;text-shadow:0 2px 0 rgba(0,0,0,.35)}
  .pill small{opacity:.95}
  /* モーダル(スタート/ゲームオーバー) */
  .card{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:rgba(0,0,0,.55);text-align:center;padding:18px;z-index:6
  }
  .title{
    font-weight:900;font-size:40px;letter-spacing:.6px;margin-bottom:10px;
    text-shadow:
      0 2px 0 #000, 2px 0 0 #000, -2px 0 0 #000, 0 -2px 0 #000,
      2px 2px 0 #000, -2px 2px 0 #000, 2px -2px 0 #000, -2px -2px 0 #000;
  }
  .subtitle{font-weight:800;font-size:22px;margin:8px 0 12px;text-shadow:0 2px 0 #000}
  .howto{font-weight:800;font-size:20px;margin:6px 0 14px;text-shadow:0 2px 0 #000}
  .desc{
    font-weight:800;font-size:18px;opacity:.95;margin:6px 0 18px;line-height:1.5;
    text-shadow:0 2px 0 #000
  }
  .btn{
    display:inline-grid;place-items:center;min-width:140px;height:56px;border-radius:22px;
    padding:0 22px;background:var(--accent);color:#222;font-weight:900;font-size:22px;
    box-shadow:0 5px 0 #caa132;border:0
  }
</style>

<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill"><b id="sc">Score 0</b><small id="scsub">&nbsp;</small></div>
  <div class="pill"><b id="cm">Combo 0</b><small id="cmsub">&nbsp;</small></div>
  <div class="pill"><b id="bs">Best 0</b><small id="lvl">/ Lv.1</small></div>
</div>

<!-- スタート画面：スーファミっぽく -->
<div class="card" id="start">
  <div class="title">レッツ！ピンポン！！</div>
  <div class="subtitle">ラリーを楽しもう</div>
  <div class="howto">円が重なる瞬間に TAP!</div>
  <div class="desc">Perfect / Great / Good で加点＆コンボ。90秒で激ムズモード。</div>
  <button id="go" class="btn">スタート</button>
</div>

<div class="card" id="over" style="display:none">
  <div id="final" class="title" style="font-size:34px">Score 0 / Lv.1</div>
  <button id="retry" class="btn">もう一回</button>
</div>

<script>
(()=>{
// ====== 画像ファイル名（あなた指定どおり） ======
const BG_ROOM_URL   = './F0BDAD6E-3A4B-49E8-86BF-73CE3EAA6C58.png'; // 台なし背景
const TABLE_FG_URL  = './IMG_4406.png';   // 台＋ネット前景（PNG）
const OPP_IDLE_URL  = './IMG_4414.png';
const OPP_SWING_URL = './IMG_4413.png';
const OPP_FOLLOW_URL= './IMG_4412.png';

// ====== 調整用パラメータ ======
const NET_Y = 0.595;                // ネット高さ（画面比）
const Y_PLAYER = 0.115, Y_OPP = 0.085, X_MARGIN = 0.16, Y_JIT = 0.018;
const START_DUR  = 1.00, SPEEDUP_EVERY = 2, SPEEDUP_RATE = 0.93, MIN_DUR = 0.46;
const ARC_H = 0.12, CURVE_X = 0.10; // ベジェ弧
const RING_BASE=28, RING_SHRINK=36;
const TOL_DIST_GOOD=36, TOL_DIST_GREAT=22, TOL_DIST_PERF=12;
const TOL_TIME_GOOD=12, TOL_TIME_GREAT=7, TOL_TIME_PERF=3;
const SCORE_BASE=100, MULT_GOOD=1.00, MULT_GREAT=1.30, MULT_PERF=1.60;
const COMBO_BONUS=0.15;
const DEMON_AT=90;
const NET_MASK_H = 0.075;           // ネット帯マスクの高さ（画面比）：透け防止
const NET_MASK_COLOR = '#0b2a45';   // ネット裏の塗り色（不透明）

// 相手キャラの見た目位置と大きさ（必要なら微調整）
const CHAR_H_FRAC = 0.34;           // 画面高に対するキャラ高さ
const CHAR_Y_OFFSET = -0.020;       // バックコート側へ微調整（負で上寄せ）
const CHAR_X_FRAC = 0.50;           // 中央

// ====== DOM/Canvas ======
const cv = document.getElementById('cv'), g = cv.getContext('2d');
const S = document.getElementById('start'), O = document.getElementById('over');
const go = document.getElementById('go'), retry = document.getElementById('retry');
const F = document.getElementById('final');
const sc = document.getElementById('sc'), scs = document.getElementById('scsub');
const cm = document.getElementById('cm'), cms = document.getElementById('cmsub');
const bs = document.getElementById('bs'), lvl = document.getElementById('lvl');

let W=0,H=0,dpr=1;
function fit(){ dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',fit,{passive:true}); fit();

// ====== 画像ロード ======
function loadImage(src){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res(i); i.src=src; }); }
let bgRoom=null, tableFg=null, opIdle=null, opSwing=null, opFollow=null;
Promise.all([
  loadImage(BG_ROOM_URL), loadImage(TABLE_FG_URL),
  loadImage(OPP_IDLE_URL), loadImage(OPP_SWING_URL), loadImage(OPP_FOLLOW_URL)
]).then(([a,b,c,d,e])=>{ bgRoom=a; tableFg=b; opIdle=c; opSwing=d; opFollow=e; });

// ====== Audio（SE + BGM） ======
let AC=null, master=null, bgmNode=null;
function ensureAC(){ if(AC) return;
  AC=new (window.AudioContext||window.webkitAudioContext)();
  master=AC.createGain(); master.gain.value=0.85; master.connect(AC.destination);
}
function sePock(){ try{
  ensureAC(); const t=AC.currentTime;
  // クリック音
  const o=AC.createOscillator(), g1=AC.createGain();
  o.type='sine'; o.frequency.setValueAtTime(1350,t);
  o.frequency.exponentialRampToValueAtTime(500,t+0.06);
  g1.gain.setValueAtTime(0.0001,t);
  g1.gain.exponentialRampToValueAtTime(0.35,t+0.005);
  g1.gain.exponentialRampToValueAtTime(0.0001,t+0.12);
  o.connect(g1).connect(master); o.start(t); o.stop(t+0.14);
  // エア抜けノイズ
  const buf=AC.createBuffer(1, AC.sampleRate*0.07, AC.sampleRate);
  const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2);
  const n=AC.createBufferSource(); n.buffer=buf; const g2=AC.createGain(); g2.gain.value=0.12;
  n.connect(g2).connect(master); n.start(t); n.stop(t+0.07);
}catch{}}
function startBGM(){ try{
  ensureAC(); if(bgmNode){try{bgmNode.disconnect();}catch{} bgmNode=null;}
  const t0=AC.currentTime, tempo=122/60;          // ノリのいい8bit進行
  const seq=[440,330,523,392];                    // A4-E4-C5-G4（I-V-vi-IV風）
  const g=AC.createGain(); g.gain.value=0.08; g.connect(master); bgmNode=g;
  for(let bar=0; bar<64; bar++){
    for(let i=0;i<4;i++){
      const o=AC.createOscillator(); o.type='square'; o.frequency.value=seq[i]; o.connect(g);
      const st=t0 + (bar*4+i)*0.5/tempo, ed=st+0.45/tempo; o.start(st); o.stop(ed);
    }
    // ベースの短打
    const b=AC.createOscillator(), gb=AC.createGain();
    b.type='triangle'; b.frequency.value=110; gb.gain.value=0.06;
    b.connect(gb).connect(master);
    const bst=t0 + bar*2/tempo, bed=bst+0.4/tempo; b.start(bst); b.stop(bed);
  }
  if(AC.state==='suspended'){AC.resume().catch(()=>{});}
}catch{}}
function safeBootAudio(){ try{ ensureAC(); if(AC.state==='suspended') AC.resume().catch(()=>{}); startBGM(); }catch{} }

// ====== 乱数・座標 ======
const R=Math.random, rnd=(a,b)=>a+R()*(b-a), sec=()=>performance.now()/1000;
const oppSpot =()=>({ x:rnd(W*X_MARGIN,W*(1-X_MARGIN)),
  y:H*NET_Y - H*Y_OPP + rnd(-H*Y_JIT,H*Y_JIT) });
const plySpot =()=>({ x:rnd(W*X_MARGIN,W*(1-X_MARGIN)),
  y:H*NET_Y + H*Y_PLAYER + rnd(-H*Y_JIT,H*Y_JIT) });

// ====== ゲーム状態 ======
let playing=false, t0=0, dur=START_DUR, phase='toPlayer';
let from={x:0,y:0}, to={x:0,y:0}, ctrl={x:0,y:0};
let playerAim={x:0,y:0}, oppAim={x:0,y:0};
let score=0, combo=0, best=Number(localStorage.getItem('PT_best')||0), level=1, steps=0, startedAt=0;
bs.textContent='Best '+best.toFixed(0);
let judgeText='', judgeUntil=0;
const showJudge=txt=>{judgeText=txt; judgeUntil=sec()+0.85;};

// ベジェ
const bez=(p,a,c,b)=>{const u=1-p; return u*u*a+2*u*p*c+p*p*b;}
function setLeg(a,b){
  from=a; to=b; t0=sec();
  const midx=(a.x+b.x)/2, curve=(b.x-a.x)*rnd(-CURVE_X, CURVE_X);
  ctrl={ x:midx+curve, y:H*NET_Y - H*ARC_H*rnd(0.85,1.15) };
}

// ====== 開始・終了 ======
function resetState(){
  score=0; combo=0; level=1; steps=0; dur=START_DUR;
  sc.textContent='Score 0'; scs.innerHTML='&nbsp;'; cm.textContent='Combo 0'; cms.innerHTML='&nbsp;';
  lvl.textContent='/ Lv.1';
  playerAim=plySpot(); oppAim=oppSpot();
  phase='toPlayer'; startedAt=sec(); setLeg(oppAim, playerAim);
  judgeText=''; judgeUntil=0;
}
function startGame(){ safeBootAudio(); resetState(); S.style.display='none'; O.style.display='none'; playing=true; }
function gameOver(){
  playing=false; if(score>best){best=score; localStorage.setItem('PT_best',best);}
  bs.textContent='Best '+best.toFixed(0); F.textContent='Score '+score.toFixed(0)+' / Lv.'+level; O.style.display='flex';
}

// ====== 入力（自分の番のみ判定） ======
addEventListener('pointerdown', e=>{
  if(!playing || phase!=='toPlayer') return;
  const r=cv.getBoundingClientRect();
  const x=(e.clientX??e.touches?.[0]?.clientX)-r.left, y=(e.clientY??e.touches?.[0]?.clientY)-r.top;
  const rr=ringRadiusNow(), dt=Math.abs(rr-RING_BASE), d=Math.hypot(x-playerAim.x,y-playerAim.y);
  let mult=0, tag='';
  if(dt<=TOL_TIME_PERF && d<=TOL_DIST_PERF){ mult=MULT_PERF; tag='Perfect!'; }
  else if(dt<=TOL_TIME_GREAT && d<=TOL_DIST_GREAT){ mult=MULT_GREAT; tag='Great!'; }
  else if(dt<=TOL_TIME_GOOD && d<=TOL_DIST_GOOD){ mult=MULT_GOOD; tag='Good!'; }

  if(mult>0){
    sePock();
    const add=Math.round(SCORE_BASE*mult*(1+combo*COMBO_BONUS));
    score+=add; combo++; steps++; sc.textContent='Score '+score.toFixed(0); scs.textContent='+'+add;
    cm.textContent='Combo '+combo; cms.textContent=tag; showJudge(tag);
    if(steps%SPEEDUP_EVERY===0){ const elapsed=sec()-startedAt; const rate=(elapsed>=DEMON_AT)?0.90:SPEEDUP_RATE;
      dur=Math.max(MIN_DUR,dur*rate); level++; lvl.textContent='/ Lv.'+level; }
    phase='toOpponent'; oppAim=oppSpot(); setLeg(playerAim, oppAim);
  }else{ cms.textContent='Miss!'; showJudge('Miss!'); gameOver(); }
},{passive:true});

function ringRadiusNow(){ const p=Math.min(1,Math.max(0,(sec()-t0)/dur)); const left=(phase==='toPlayer')?(1-p):1; return RING_BASE+RING_SHRINK*left; }

// ====== ループ描画 ======
let last=sec(); function loop(){
  const now=sec(); last=now;

  // 背景（台なし）
  if(bgRoom){
    const r=Math.max(W/bgRoom.width, H/bgRoom.height);
    const ox=(W-bgRoom.width*r)/2, oy=(H-bgRoom.height*r)/2;
    g.drawImage(bgRoom, ox, oy, bgRoom.width*r, bgRoom.height*r);

    // 相手キャラ（アニメ：相手側の時はスイング→フォロー短時間）
    let opImg=opIdle;
    if(phase==='toOpponent'){ const p=(now-t0)/dur;
      if(p>0.70 && p<0.84) opImg=opSwing; else if(p>=0.84 && p<0.94) opImg=opFollow; else opImg=opIdle;
    }
    if(opImg){
      const ch = H*CHAR_H_FRAC;
      const cw = ch * (opImg.width/opImg.height);
      const cx = W*CHAR_X_FRAC - cw/2;
      const baseY = H*NET_Y + H*CHAR_Y_OFFSET; // ネットの少し上を足元に
      const cy = baseY - ch;
      g.imageSmoothingEnabled=false; // ドット感キープ
      g.drawImage(opImg, cx, cy, cw, ch);
      g.imageSmoothingEnabled=true;
    }

    // ネット裏マスク（透け防止）
    const nmH = H*NET_MASK_H;
    g.fillStyle = NET_MASK_COLOR;
    g.fillRect(0, H*NET_Y - nmH/2, W, nmH);

    // 台＋ネット前景（PNG）
    if(tableFg){ g.drawImage(tableFg, ox, oy, tableFg.width*r, tableFg.height*r); }
  }

  if(playing){
    // ベジェ位置
    const p = Math.min(1,(now-t0)/dur);
    const bx = bez(p, from.x, ctrl.x, to.x);
    const by = bez(p, from.y, ctrl.y, to.y);

    // フェーズ更新／相手ヒットSE
    if(p>=1){
      if(phase==='toPlayer'){ gameOver(); }
      else { sePock(); phase='toPlayer'; playerAim=plySpot(); setLeg(oppAim, playerAim); }
    }

    // ガイド（相手側の円・HITは削除）
    const rr = ringRadiusNow();
    drawGuide(playerAim.x, playerAim.y, rr, true, (judgeUntil>now)?judgeText:'TAP!');

    // ボール（前面）
    const hNorm = 1 - 4*(p-0.5)*(p-0.5);
    const rad = 8*(1+0.08*hNorm);
    g.globalAlpha = 0.25*(1-hNorm);
    g.fillStyle='#000'; g.beginPath(); g.ellipse(bx+2, by+6, rad*0.9, rad*0.55, 0, 0, Math.PI*2); g.fill();
    g.globalAlpha = 1;
    g.fillStyle='#fff'; g.beginPath(); g.arc(bx,by,rad,0,Math.PI*2); g.fill();
  }

  // 激ムズモード帯
  if(playing && (now-startedAt)>=DEMON_AT){ g.fillStyle='rgba(255,80,80,.18)'; g.fillRect(0,0,W,6); }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ====== 描画ユーティリティ ======
function drawGuide(x,y,rr,isPlayer,label){
  g.beginPath(); g.lineWidth=3; g.setLineDash([]);
  g.strokeStyle=isPlayer?'var(--ringP)':'var(--ringO)'; g.arc(x,y,RING_BASE,0,Math.PI*2); g.stroke();
  g.beginPath(); g.lineWidth=3; g.setLineDash(isPlayer?[6,6]:[]); g.strokeStyle=isPlayer?'var(--ringP)':'var(--ringO)';
  g.arc(x,y,rr,0,Math.PI*2); g.stroke(); g.setLineDash([]);
  g.fillStyle=isPlayer?'#ffe38a':'#aee1ff'; g.font='900 16px system-ui'; g.textAlign='center';
  g.fillText(label, x, y-RING_BASE-10);
}

// ====== ボタン（安全起動） ======
function onStart(e){ e.preventDefault(); safeBootAudio(); startGame(); }
function onRetry(e){ e.preventDefault(); S.style.display='flex'; O.style.display='none'; }
go.addEventListener('click', onStart, {passive:false});
go.addEventListener('touchstart', onStart, {passive:false});
retry.addEventListener('click', onRetry, {passive:false});
retry.addEventListener('touchstart', onRetry, {passive:false});
// 初回操作で必ずAudio起動
window.addEventListener('touchstart', ()=>{ try{ ensureAC(); AC.resume(); }catch{} }, {once:true, passive:true});
window.addEventListener('mousedown', ()=>{ try{ ensureAC(); AC.resume(); }catch{} }, {once:true, passive:true});

})();
</script>