<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=M+PLUS+1p:wght@700&display=swap" rel="stylesheet">
<style>
  :root{
    --hud-bg: rgba(28,26,50,.65);
    --pill-1:#ffd34d;  /* Score */
    --pill-2:#9cf1ff;  /* Combo */
    --pill-3:#b0ffa6;  /* Best  */
    --ringP: rgba(255,235,150,.95);
    --accent:#ffd34d;
  }
  html,body{margin:0;height:100%;background:#091427;color:#fff;
    font-family:"M PLUS 1p",-apple-system,BlinkMacSystemFont,"Noto Sans JP",system-ui,sans-serif}
  #cv{position:fixed;inset:0;touch-action:manipulation}

  /* ===== HUD（見切れ対策＋ポップ化） ===== */
  .hud{
    position:fixed;left:10px;right:10px;
    top:calc(env(safe-area-inset-top,0px) + 8px);
    display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
    gap:12px;z-index:6;pointer-events:none
  }
  .pill{background:var(--hud-bg);backdrop-filter: blur(3px);
        border-radius:16px;padding:10px 12px;font-weight:800;letter-spacing:.2px}
  .pill b{display:block;font-family:"Press Start 2P","M PLUS 1p",sans-serif;font-size:14px;line-height:1.2}
  .pill small{opacity:.95;font-size:12px}
  #sc{color:var(--pill-1)} #cm{color:var(--pill-2)} #bs{color:var(--pill-3)}

  /* ===== Start / Result ===== */
  .card{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:rgba(0,0,0,.55);text-align:center;padding:18px;z-index:7
  }
  .title{font-family:"Press Start 2P","M PLUS 1p",sans-serif;font-size:28px;margin-bottom:16px;letter-spacing:.5px;
         text-shadow:0 2px 0 #000, 0 0 8px rgba(255,211,77,.28)}
  .line{opacity:.98;margin:.4rem 0;font-weight:800}
  .btn{
    display:inline-grid;place-items:center;min-width:46px;height:46px;border-radius:18px;
    padding:0 18px;background:linear-gradient(#ffe071,#ffbf2a);
    color:#222;font-weight:900;box-shadow:0 4px 0 #caa132;border:0;font-size:16px;margin-top:16px
  }
</style>

<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill"><b id="sc">Score 0</b><small id="scsub">&nbsp;</small></div>
  <div class="pill"><b id="cm">Combo 0</b><small id="cmsub">&nbsp;</small></div>
  <div class="pill"><b id="bs">Best 0</b><small id="lvl">/ Lv.1</small></div>
</div>

<!-- Start -->
<div class="card" id="start">
  <div class="title">レッツ！ピンポン！！</div>
  <div class="line">ラリーを楽しもう</div>
  <div class="line">円が重なる瞬間にTAP!</div>
  <div class="line" style="opacity:.9;margin-top:6px">Perfect / Great / Good で加点＆コンボ。90秒で<strong>激ムズモード</strong>。</div>
  <button id="go" class="btn">スタート</button>
</div>

<!-- Game Over -->
<div class="card" id="over" style="display:none">
  <div id="final" class="title" style="font-size:22px">Score 0 / Lv.1</div>
  <button id="retry" class="btn">もう一回</button>
</div>

<script>
(()=>{
/* ====== 画像名（指定通り） ====== */
const BG_URL  ='F0BDAD6E-3A4B-49E8-86BF-73CE3EAA6C58.png'; // 台が無い背景
const FG_URL  ='IMG_4406.png'; // 台＋ネット（前景）
const OPP_IDLE='IMG_4414.png';
const OPP_SW  ='IMG_4413.png';
const OPP_FOL ='IMG_4412.png';

/* ====== 調整パラメータ ====== */
const NET_Y   = 0.595;
const Y_PLAYER= 0.115, Y_OPP=0.085, X_MARGIN=0.16, Y_JIT=0.018;

const START_DUR=1.00, SPEEDUP_EVERY=2, SPEEDUP_RATE=0.93, MIN_DUR=0.46;
const HARD_AT=90;

const RING_BASE=28, RING_SHRINK=36;
const TOL_DIST_GOOD=36, TOL_DIST_GREAT=22, TOL_DIST_PERF=12;
const TOL_TIME_GOOD=12, TOL_TIME_GREAT=7,  TOL_TIME_PERF=3;
const SCORE_BASE=100, MULT_GOOD=1.00, MULT_GREAT=1.30, MULT_PERF=1.60, COMBO_BONUS=0.15;

/* 前景サイズ調整（台がデカくなる対策） */
const FG_SCALE=0.86;         // 0.80〜0.90で微調整
const FG_NET_Y_RATIO=0.565;  // 画像内でネット中心がある高さ（画像高に対する比）
const FG_Y_TWEAK=0;          // +で下げる / -で上げる（px）

/* 相手の見た目 */
const OPP_SCALE=1.22; /* ほどよい大きさ */ 
const OPP_DOWN =0.034;/* 台に少し寄せる */

/* 軌道（ベジェ） */
const ARC_H=0.12, CURVE_X=0.10;

/* 透けマスク（ネット裏の帯） */
const NET_OCCLUDER_H=0.085;
const NET_OCCLUDER_CLR='rgba(7,18,38,.86)';

/* ====== DOM/Canvas ====== */
const cv=document.getElementById('cv'), g=cv.getContext('2d');
const S=document.getElementById('start'), O=document.getElementById('over');
const go=document.getElementById('go'), retry=document.getElementById('retry'), F=document.getElementById('final');
const sc=document.getElementById('sc'), scs=document.getElementById('scsub');
const cm=document.getElementById('cm'), cms=document.getElementById('cmsub');
const bs=document.getElementById('bs'), lvl=document.getElementById('lvl');

let W=0,H=0,dpr=1;
function fit(){ dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',fit,{passive:true}); fit();

/* ====== 画像ロード ====== */
function load(src){return new Promise(res=>{const i=new Image(); i.onload=()=>res(i); i.src=src;});}
let bgImg, fgImg, oppIdle, oppSwing, oppFollow;
Promise.all([load(BG_URL),load(FG_URL),load(OPP_IDLE),load(OPP_SW),load(OPP_FOL)]).then(v=>{
  [bgImg, fgImg, oppIdle, oppSwing, oppFollow]=v;
});

/* ====== 音（SE＋軽BGM） ====== */
let AC=null, master=null, bgmGain=null, bgmNodes=[];
function ac(){ if(AC) return; AC=new (window.AudioContext||window.webkitAudioContext)();
  master=AC.createGain(); master.gain.value=.9; master.connect(AC.destination); }
function sePock(){
  ac(); const t=AC.currentTime;
  const o=AC.createOscillator(), g1=AC.createGain();
  o.type='sine'; o.frequency.setValueAtTime(1350,t);
  o.frequency.exponentialRampToValueAtTime(520,t+.06);
  g1.gain.setValueAtTime(.0001,t);
  g1.gain.exponentialRampToValueAtTime(.35,t+.005);
  g1.gain.exponentialRampToValueAtTime(.0001,t+.12);
  o.connect(g1).connect(master); o.start(t); o.stop(t+.14);
  const buf=AC.createBuffer(1,AC.sampleRate*.07,AC.sampleRate);
  const ch=buf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.pow(1-i/ch.length,2);
  const n=AC.createBufferSource(); const g2=AC.createGain(); g2.gain.value=.12; n.buffer=buf; n.connect(g2).connect(master);
  n.start(t); n.stop(t+.07);
}
function startBGM(){
  ac(); stopBGM();
  bgmGain=AC.createGain(); bgmGain.gain.value=.10; bgmGain.connect(master);
  const tempo=120/60, t0=AC.currentTime, pat=[0,5,9,7]; // I–V–vi–IV
  for(let bar=0; bar<64; bar++){
    for(let i=0;i<4;i++){
      const o=AC.createOscillator(); o.type='square';
      const base=440, semi=[0,2,4,5,7,9,11,12];
      const hz= base * Math.pow(2,(semi[pat[i]%semi.length]+12*Math.floor(pat[i]/semi.length)-9)/12);
      o.frequency.value=hz;
      const st=t0+(bar*4+i)*0.5/tempo, ed=st+0.45/tempo;
      o.connect(bgmGain); o.start(st); o.stop(ed); bgmNodes.push(o);
    }
  }
}
function stopBGM(){ bgmNodes.forEach(n=>{try{n.disconnect();}catch{}}); bgmNodes=[]; }

/* ====== 打点生成 ====== */
const R=Math.random, rnd=(a,b)=>a+R()*(b-a);
const oppSpot=()=>({x:rnd(W*X_MARGIN,W*(1-X_MARGIN)), y:H*NET_Y - H*Y_OPP + rnd(-H*Y_JIT,H*Y_JIT)});
const plySpot=()=>({x:rnd(W*X_MARGIN,W*(1-X_MARGIN)), y:H*NET_Y + H*Y_PLAYER + rnd(-H*Y_JIT,H*Y_JIT)});

/* ====== 状態 ====== */
const sec=()=>performance.now()/1000;
let playing=false, t0=0, dur=START_DUR, phase='toPlayer';
let from={x:0,y:0}, to={x:0,y:0}, ctrl={x:0,y:0};
let playerAim={x:0,y:0}, oppAim={x:0,y:0};
let score=0, combo=0, best=Number(localStorage.getItem('PT_best')||0), level=1, steps=0, startedAt=0;
bs.textContent='Best '+best.toFixed(0);
let judgeText='', judgeUntil=0; const showJudge=txt=>{judgeText=txt; judgeUntil=sec()+.85;};
let oppPose='idle', oppPoseUntil=0;

/* ベジェ */
const bez=(p,a,c,b)=>{const u=1-p; return u*u*a + 2*u*p*c + p*p*b;};
function setLeg(a,b){
  from=a; to=b; t0=sec();
  const midx=(a.x+b.x)/2, curve=(b.x-a.x)*rnd(-CURVE_X, CURVE_X);
  ctrl={x:midx+curve, y:H*NET_Y - H*ARC_H * rnd(.85,1.15)};
}

/* ====== 開始／終了 ====== */
function resetState(){
  score=0; combo=0; level=1; steps=0; dur=START_DUR;
  sc.textContent='Score 0'; scs.innerHTML='&nbsp;'; cm.textContent='Combo 0'; cms.innerHTML='&nbsp;';
  lvl.textContent='/ Lv.1';
  playerAim=plySpot(); oppAim=oppSpot();
  phase='toPlayer'; startedAt=sec(); setLeg(oppAim, playerAim);
  judgeText=''; judgeUntil=0; oppPose='idle'; oppPoseUntil=0;
}
function startGame(){ resetState(); S.style.display='none'; O.style.display='none'; playing=true; startBGM(); }
function gameOver(){
  playing=false; stopBGM();
  if(score>best){ best=score; localStorage.setItem('PT_best',best); }
  bs.textContent='Best '+best.toFixed(0);
  F.textContent='Score '+score.toFixed(0)+' / Lv.'+level;
  O.style.display='flex';
}

/* ====== タップ判定 ====== */
addEventListener('pointerdown',e=>{
  if(!playing||phase!=='toPlayer') return;
  const r=cv.getBoundingClientRect(), x=(e.clientX??e.touches?.[0]?.clientX)-r.left, y=(e.clientY??e.touches?.[0]?.clientY)-r.top;
  const rr=ringRadiusNow(), dt=Math.abs(rr-RING_BASE), d=Math.hypot(x-playerAim.x,y-playerAim.y);
  let mult=0, tag='';
  if(dt<=TOL_TIME_PERF && d<=TOL_DIST_PERF){ mult=MULT_PERF; tag='Perfect!'; }
  else if(dt<=TOL_TIME_GREAT && d<=TOL_DIST_GREAT){ mult=MULT_GREAT; tag='Great!'; }
  else if(dt<=TOL_TIME_GOOD && d<=TOL_DIST_GOOD){ mult=MULT_GOOD; tag='Good!'; }
  if(mult>0){
    sePock();
    const add=Math.round(SCORE_BASE*mult*(1+combo*COMBO_BONUS));
    score+=add; combo++; steps++;
    sc.textContent='Score '+score.toFixed(0); scs.textContent='+'+add;
    cm.textContent='Combo '+combo; cms.textContent=tag; showJudge(tag);
    if(steps%SPEEDUP_EVERY===0){ const elapsed=sec()-startedAt, rate=(elapsed>=HARD_AT)?0.90:SPEEDUP_RATE;
      dur=Math.max(MIN_DUR, dur*rate); level++; lvl.textContent='/ Lv.'+level; }
    phase='toOpponent'; oppAim=oppSpot(); setLeg(playerAim, oppAim);
  }else{ cms.textContent='Miss!'; showJudge('Miss!'); gameOver(); }
},{passive:true});

/* ====== 時計 ====== */
function ringRadiusNow(){ const p=Math.min(1,Math.max(0,(sec()-t0)/dur));
  const left=(phase==='toPlayer')?(1-p):1; return RING_BASE + RING_SHRINK*left; }

/* ====== ループ ====== */
let last=sec();
function loop(){
  const now=sec(); last=now;

  // 背景（台なし）
  if(bgImg){ const r=Math.max(W/bgImg.width,H/bgImg.height), w=bgImg.width*r, h=bgImg.height*r;
    g.drawImage(bgImg,(W-w)/2,(H-h)/2,w,h); }
  else { g.fillStyle='#13223f'; g.fillRect(0,0,W,H); }

  // 相手（前景より前に描かない）→奥側に配置
  drawOpponent(now);

  // ネット透け防止の帯
  g.fillStyle=NET_OCCLUDER_CLR;
  const netH=H*NET_OCCLUDER_H, netY=H*NET_Y - netH/2; g.fillRect(0, netY, W, netH);

  // 前景（台＋ネット）— ここが“デカくならない”描画
  if(fgImg){
    const r = Math.min(W/fgImg.width, H/fgImg.height) * FG_SCALE;  // containベース
    const w = fgImg.width*r, h = fgImg.height*r;
    const x = (W-w)/2;
    const y = (H*NET_Y - h*FG_NET_Y_RATIO) + FG_Y_TWEAK;           // ネット位置を基準に揃える
    g.drawImage(fgImg, x, y, w, h);
  }

  if(playing){
    const p=Math.min(1,(now-t0)/dur);
    const bx=bez(p,from.x,ctrl.x,to.x), by=bez(p,from.y,ctrl.y,to.y);

    if(p>=1){
      if(phase==='toPlayer'){ gameOver(); }
      else {
        sePock(); oppPose='swing'; oppPoseUntil=now+.12;
        setTimeout(()=>{oppPose='follow'; oppPoseUntil=now+.28;},120);
        setTimeout(()=>{oppPose='idle';},280);
        phase='toPlayer'; playerAim=plySpot(); setLeg(oppAim, playerAim);
      }
    }

    // 自分ガイドだけ
    const rr=ringRadiusNow(); drawGuide(playerAim.x,playerAim.y,rr,(judgeUntil>now)?judgeText:'TAP!');

    // ボール（最前面）
    const hNorm=1-4*(p-0.5)*(p-0.5), rad=8*(1+0.08*hNorm);
    g.globalAlpha=0.25*(1-hNorm);
    g.fillStyle='#000'; g.beginPath(); g.ellipse(bx+2,by+6,rad*0.9,rad*0.55,0,0,Math.PI*2); g.fill();
    g.globalAlpha=1; g.fillStyle='#fff'; g.beginPath(); g.arc(bx,by,rad,0,Math.PI*2); g.fill();
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== 描画ヘルパ ====== */
function drawGuide(x,y,rr,label){
  g.beginPath(); g.lineWidth=3; g.setLineDash([]); g.strokeStyle='var(--ringP)';
  g.arc(x,y,RING_BASE,0,Math.PI*2); g.stroke();
  g.beginPath(); g.lineWidth=3; g.setLineDash([6,6]); g.strokeStyle='var(--ringP)';
  g.arc(x,y,rr,0,Math.PI*2); g.stroke(); g.setLineDash([]);
  g.fillStyle='#ffe38a'; g.font='700 14px "M PLUS 1p",system-ui'; g.textAlign='center'; g.fillText(label, x, y-RING_BASE-10);
}
function drawOpponent(now){
  if(!oppIdle) return;
  const img = (now<oppPoseUntil && oppPose==='swing') ? oppSwing
            : (now<oppPoseUntil && oppPose==='follow') ? oppFollow
            : oppIdle;
  const r = Math.min(W/img.width, H/img.height) * OPP_SCALE;
  const w=img.width*r, h=img.height*r;
  const x=(W-w)/2;
  const baseY= H*(NET_Y - 0.22 + OPP_DOWN);
  const y= baseY - h;
  g.imageSmoothingEnabled=false;
  g.drawImage(img,x,y,w,h);
  g.imageSmoothingEnabled=true;
}

/* ====== ボタン ====== */
go.onclick=()=>{ ac(); startBGM(); startGame(); };
retry.onclick=()=>{ S.style.display='flex'; O.style.display='none'; };
})();
</script>