<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally (SNES cut)</title>
<style>
  :root{
    --hud:#0b0f1aee;
    --accent:#ffd34d; --accent2:#ffec9a;
  }
  html,body{margin:0;height:100%;background:#091426;color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Noto Sans JP",system-ui}
  #cv{position:fixed;inset:0;display:block;background:#091426}
  .hudbar{position:fixed;left:10px;right:10px;top:8px;display:flex;gap:14px;z-index:20}
  .pill{flex:1;max-width:42%;background:var(--hud);padding:10px 14px;border-radius:18px;font-weight:700;text-shadow:0 1px 0 rgba(0,0,0,.4)}
  .pill small{opacity:.85}
  #pause{position:fixed;top:10px;right:10px;z-index:25;background:var(--hud);border:0;border-radius:10px;color:#fff;padding:8px 10px;font-weight:900}
  .card{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.55);z-index:30}
  .panel{background:#0f1422;border-radius:14px;padding:18px 22px;box-shadow:0 6px 24px rgba(0,0,0,.4);text-align:center}
  .btn{margin-top:12px;padding:10px 18px;border:0;border-radius:12px;background:var(--accent);color:#222;font-weight:800;box-shadow:0 4px 0 #caa132}
  .muted{opacity:.8;font-size:12px}
  #pauseLayer{display:none}
</style>

<canvas id="cv"></canvas>

<div class="hudbar">
  <div id="scoreP" class="pill">Score <span id="scv">0</span></div>
  <div id="comboP" class="pill">Combo <span id="cbv">0</span></div>
  <div id="bestP"  class="pill"><small>Best</small> <span id="bev">0</span> <small>/ Lv.<span id="lv">1</span></small></div>
</div>
<button id="pause">Ⅱ</button>

<!-- START -->
<div class="card" id="start">
  <div class="panel">
    <div style="font-size:22px;margin-bottom:6px">PingTap — Retro Rally</div>
    <div class="muted">45〜90秒レンジで勝負！90秒超は鬼モード</div>
    <button class="btn" id="go">スタート</button>
    <div class="muted" style="margin-top:8px">※初回タップ後にBGMが自動で鳴ります</div>
  </div>
</div>

<!-- OVER -->
<div class="card" id="over" style="display:none">
  <div class="panel">
    <div id="fin" style="font-size:20px;margin-bottom:8px"></div>
    <button class="btn" id="retry">もう一回</button>
  </div>
</div>

<!-- PAUSE -->
<div class="card" id="pauseLayer">
  <div class="panel">
    <div style="font-size:20px;margin-bottom:8px">PAUSED</div>
    <button class="btn" id="resume">再開</button>
  </div>
</div>

<script>
(()=>{
/* ========= 調整 ========= */
/* 画面基準（背景の机と合うよう“ネット寄り”に固定） */
const NET_Y_F   = 0.585;       // 背景ネット上辺のだいたい位置 (画面比)
const PLAYER_OF = 0.090;       // 自陣打点：ネットから下へ
const OPP_OF    = 0.060;       // 相手打点：ネットから上へ
const X_MARGIN  = 0.16;        // サイドの余白（左右に打ち分けランダム）
const Y_JITTER  = 0.016;       // わずかな上下ランダム（見た目の自然さ）

/* 速度カーブ（“近づかず速くなるだけ”） */
const START_DUR = 0.98;        // 開始時の飛翔時間（1レグ）
const SPEED_DEC = 0.94;        // 毎ヒット掛け率（速くなる）
const MIN_DUR   = 0.52;        // 下限（ここ以下は落とさない）
const RAGE_AT   = 90;          // 鬼モード突入秒
const RAGE_DEC  = 0.90;        // 鬼モード中の掛け率
const RAGE_MIN  = 0.36;        // 鬼モード下限（ほぼ無理）
const HARD_STOP = 120;         // 2分で強制終了

/* 判定（少し締め気味） */
const RING_BASE=26, RING_SHRINK=26;
const MATCH_TOL=6.0;           // リング合致の許容
const HIT_TOL  =36;            // 中心距離の許容

/* 演出 */
const BG_BRIGHTEN=0.10;

/* ========= 要素 ========= */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const S=document.getElementById('start'), O=document.getElementById('over'), F=document.getElementById('fin');
const GO=document.getElementById('go'), RY=document.getElementById('retry');
const pauseBtn=document.getElementById('pause'), pauseLayer=document.getElementById('pauseLayer'), resumeBtn=document.getElementById('resume');
const SC=document.getElementById('scv'), CB=document.getElementById('cbv'), BE=document.getElementById('bev'), LV=document.getElementById('lv');

/* ========= 画面/背景 ========= */
let W=0,H=0,dpr=1, last=performance.now(), bgImg=null;
function resize(){ dpr=Math.max(1,Math.min(3,devicePixelRatio||1)); W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize',resize);

/* 背景読み込み（失敗時はグラデ） */
(function(){
  const i=new Image(); i.crossOrigin='anonymous';
  i.onload=()=>{ bgImg=i; }; i.onerror=()=>{ bgImg=null; };
  i.src='2FE72969-9374-4D85-ADBC-28EADEE8437A.png?v=4';
})();

function drawBG(){
  if(!bgImg){ // フォールバック
    const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0e223f'); g.addColorStop(1,'#0a1326');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  }else{
    const r=Math.max(W/bgImg.width,H/bgImg.height);
    const w=bgImg.width*r, h=bgImg.height*r, x=(W-w)/2, y=(H-h)/2;
    ctx.drawImage(bgImg,x,y,w,h);
    ctx.fillStyle=`rgba(255,255,255,${BG_BRIGHTEN})`; ctx.fillRect(0,0,W,H);
  }
}

/* ========= 音（SNES風） ========= */
let ac=null, master=null, musicGain=null, sfxGain=null, musicTimer=null;
function ensureAC(){ if(ac) return; ac=new (window.AudioContext||webkitAudioContext)(); master=ac.createGain(); master.gain.value=0.9; master.connect(ac.destination);
  musicGain=ac.createGain(); musicGain.gain.value=0.18; musicGain.connect(master);
  sfxGain=ac.createGain(); sfxGain.gain.value=0.20; sfxGain.connect(master);
}
function beepHit(){ if(!ac) return; const o=ac.createOscillator(), g=ac.createGain();
  o.type='square'; o.frequency.value=1400; g.gain.value=0.0001;
  g.gain.setValueAtTime(0.0001,ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.25,ac.currentTime+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.09);
  o.connect(g).connect(sfxGain); o.start(); o.stop(ac.currentTime+0.1);
}
function beepNet(){ if(!ac) return; const o=ac.createOscillator(), g=ac.createGain();
  o.type='triangle'; o.frequency.value=220; g.gain.value=0.0001;
  g.gain.setValueAtTime(0.0001,ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.3,ac.currentTime+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.25);
  o.connect(g).connect(sfxGain); o.start(); o.stop(ac.currentTime+0.26);
}
function missSE(){ if(!ac) return; const n=ac.createBufferSource(), b=ac.createBuffer(1,ac.sampleRate*0.2,ac.sampleRate), d=b.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2); }
  const g=ac.createGain(); g.gain.value=0.35; n.buffer=b; n.connect(g).connect(sfxGain); n.start();
}
function startBGM(){ ensureAC(); if(musicTimer){clearInterval(musicTimer); musicTimer=null;}
  // 2chメロ＋簡易エコー（ディレイ）
  const delay=ac.createDelay(0.25); delay.delayTime.value=0.23;
  const fb=ac.createGain(); fb.gain.value=0.25; delay.connect(fb).connect(delay);
  delay.connect(musicGain);
  function tone(freq,dur,when,vol=0.18,type='square'){
    const o=ac.createOscillator(), g=ac.createGain();
    o.type=type; o.frequency.value=freq; g.gain.setValueAtTime(0,when);
    g.gain.linearRampToValueAtTime(vol, when+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, when+dur);
    o.connect(g); g.connect(delay); g.connect(musicGain);
    o.start(when); o.stop(when+dur+0.05);
  }
  const base=[392,440,523,392,392,440,494,392]; // G A C5 G | G A B G みたいな
  let step=0;
  musicTimer=setInterval(()=>{
    if(!ac||ac.state!=='running') return;
    const now=ac.currentTime; const t=0.18;
    // ch1
    tone(base[step%base.length], 0.16, now, 0.18,'square');
    // ch2（下で刻む）
    tone(196,0.12,now,0.12,'triangle');
    tone(196,0.12,now+0.12,0.12,'triangle');
    step++;
  },180);
}

/* ========= 状態 ========= */
let playing=false, paused=false, raf=0;
let phase='idle', dirToPlayer=true;
let t0=0, dur=START_DUR, g=1400;
let pos={x:0,y:0}, vel={x:0,y:0};
let target={x:0,y:0};
let ringText='TAP!';
let score=0, combo=0, best=+(localStorage.getItem('PT_best_v3')||0);
let speedLv=1, sessionStart=0, missLock=false;
BE.textContent=(best|0).toString();

/* ========= 入出力 ========= */
function ringR(){ const t=Math.max(0,dur-(performance.now()/1000 - t0)); return RING_BASE+RING_SHRINK*(t/dur); }
function pick(px,py){ const dx=px-target.x, dy=py-target.y; return Math.hypot(dx,dy)<=HIT_TOL; }
cv.addEventListener('pointerdown',e=>{
  const r=cv.getBoundingClientRect(); const x=(e.clientX??e.touches?.[0].clientX)-r.left, y=(e.clientY??e.touches?.[0].clientY)-r.top;
  if(!playing){ if(S.style.display!=='none') startGame(); return; }
  if(paused) return;
  if(phase!=='toPlayer') return;
  const rr=ringR(), okRadius=Math.abs(rr-RING_BASE)<=MATCH_TOL;
  if(pick(x,y)&&okRadius){ // HIT!
    beepHit();
    score += 100 + Math.max(0, 10*combo);
    combo++; if(combo%12===0){ speedLv++; LV.textContent=speedLv; }
    hud();
    speedUp();
    startLegToOpponent();
  }else{ miss(); }
},{passive:true});

/* ========= 速度/ターゲット ========= */
function playerY(){ return H*(NET_Y_F+PLAYER_OF); }
function oppY(){    return H*(NET_Y_F-OPP_OF); }
function randX(){ return W*(X_MARGIN + (1-2*X_MARGIN)*Math.random()); }
function nextTargetPlayer(){ target={x:randX(), y:playerY()+ (Math.random()*2-1)*H*Y_JITTER}; ringText='TAP!'; }
function nextTargetOpponent(){ target={x:randX(), y:oppY()+    (Math.random()*2-1)*H*Y_JITTER}; ringText='HIT!'; }

function speedUp(){
  const elapsed = performance.now()/1000 - sessionStart;
  if(elapsed>=HARD_STOP){ miss(); return; }
  if(elapsed>=RAGE_AT){ dur = Math.max(RAGE_MIN, dur*RAGE_DEC); }
  else               { dur = Math.max(MIN_DUR,  dur*SPEED_DEC); }
}

function startLegToPlayer(){
  phase='toPlayer'; t0=performance.now()/1000; nextTargetPlayer();
  const Tm=dur; vel.x=(target.x-pos.x)/Tm; vel.y=(target.y-pos.y-0.5*g*Tm*Tm)/Tm;
}
function startLegToOpponent(){
  phase='toOpponent'; t0=performance.now()/1000; nextTargetOpponent();
  const Tm=dur; vel.x=(target.x-pos.x)/Tm; vel.y=(target.y-pos.y-0.5*g*Tm*Tm)/Tm;
}

/* ========= 進行 ========= */
function startGame(){
  ensureAC(); startBGM();
  S.style.display='none'; O.style.display='none';
  hardReset();
  // 相手側からサーブ
  pos.x = W*0.5; pos.y = oppY()-60;
  startLegToPlayer();
  playing=true; sessionStart=performance.now()/1000;
  last=performance.now(); raf=requestAnimationFrame(loop);
}
function hardReset(){
  score=0; combo=0; speedLv=1; LV.textContent='1';
  dur=START_DUR; phase='idle'; missLock=false;
  SC.textContent='0'; CB.textContent='0';
}
function miss(){
  if(missLock) return; missLock=true;
  missSE(); playing=false;
  const t=performance.now()/1000 - sessionStart;
  if(score>best){ best=score; localStorage.setItem('PT_best_v3',best); }
  BE.textContent=(best|0).toString();
  F.textContent=`Score ${(score|0)} / Best ${(best|0)} / Lv.${speedLv}`;
  O.style.display='grid';
}
GO.onclick=startGame; RY.onclick=()=>{ S.style.display='grid'; O.style.display='none'; };
pauseBtn.onclick = ()=> pause(true);
resumeBtn.onclick= ()=> pause(false);
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) pause(true); });

function pause(v){
  if(!playing && !paused) return; // 何もしてない時は無視
  paused=v; pauseLayer.style.display= v?'grid':'none';
  if(v){ cancelAnimationFrame(raf); if(ac&&ac.state==='running') ac.suspend().catch(()=>{}); }
  else { if(ac&&ac.state==='suspended') ac.resume().catch(()=>{}); last=performance.now(); raf=requestAnimationFrame(loop); }
}

/* ========= HUD ========= */
function hud(){ SC.textContent=(score|0).toString(); CB.textContent=combo.toString(); }

/* ========= ループ ========= */
function loop(tms){
  const now=tms, dt=Math.min(0.033,(now-last)/1000); last=now;
  update(dt); draw();
  raf=requestAnimationFrame(loop);
}
function update(dt){
  if(!playing) return;
  // 落下
  pos.x+=vel.x*dt; pos.y+=vel.y*dt + 0.5*g*dt*dt; vel.y+=g*dt;
  // 相手コートに越えた瞬間の火花
  const netY=H*NET_Y_F;
  if(phase==='toOpponent'){ if(pos.y<=netY && (pos.y - vel.y*dt - 0.5*g*dt*dt)>netY){ beepNet(); } }
  // 到達判定（自動）
  if((performance.now()/1000 - t0)>=dur-0.01){
    if(phase==='toOpponent'){
      // 相手が打ち返した演出
      startLegToPlayer();
    }else{
      // 自陣到達時に未タップ → ミス
      miss();
    }
  }
}
function draw(){
  drawBG();
  // ボール影
  const shY=target.y; const sh=Math.max(3,18-(shY-pos.y)*0.03);
  ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.ellipse(pos.x, shY+6, sh, sh*0.5, 0,0,6.283); ctx.fill();
  // ボール
  ctx.beginPath(); ctx.fillStyle='#ffe48a'; ctx.arc(pos.x,pos.y,7,0,6.283); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.arc(pos.x-2,pos.y-2,2,0,6.283); ctx.fill();
  // リング
  const rr=ringR(); ctx.lineWidth=3; ctx.setLineDash([]);
  ctx.strokeStyle= phase==='toPlayer'?'rgba(255,220,120,.96)':'rgba(160,210,255,.96)';
  ctx.beginPath(); ctx.arc(target.x,target.y,RING_BASE,0,6.283); ctx.stroke();
  ctx.setLineDash([4,4]);
  ctx.strokeStyle= phase==='toPlayer'?'rgba(255,255,160,.9)':'rgba(190,230,255,.9)';
  ctx.beginPath(); ctx.arc(target.x,target.y,rr,0,6.283); ctx.stroke(); ctx.setLineDash([]);
  // ラベル
  ctx.fillStyle= phase==='toPlayer'?'#ffe79a':'#aee1ff';
  ctx.font='bold 14px system-ui'; ctx.textAlign='center';
  ctx.fillText( phase==='toPlayer'?'TAP!':'HIT!', target.x, target.y-RING_BASE-10 );
}

/* ========= 初期描画 ========= */
drawBG();

})();
</script>