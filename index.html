<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally</title>
<style>
  :root{
    --hud-bg: rgba(20,20,30,.55);
    --ringP: rgba(255,235,150,.95);
    --ringO: rgba(170,220,255,.92);
    --accent:#ffd34d;
    --c-score:#FFE36E; --c-combo:#A8D6FF; --c-best:#C8FF9A;
  }
  html,body{margin:0;height:100%;background:#091427;color:#fff;
    font-family:-apple-system,BlinkMacSystemFont,"Hiragino Maru Gothic ProN","M PLUS Rounded 1c","Noto Sans JP",sans-serif}
  #cv{position:fixed;inset:0;touch-action:manipulation}

  /* === HUD（常に2段：Score/Combo 上段、Best/Lv. 下段）=== */
  .hud{
    position:fixed;left:10px;right:10px;
    top:calc(10px + env(safe-area-inset-top,0px));
    display:flex;flex-wrap:wrap;gap:12px;z-index:9;pointer-events:none
  }
  .pill{
    flex:1 1 calc(50% - 6px);   /* 2列配置 */
    min-width:0;background:var(--hud-bg);backdrop-filter: blur(2px);
    border-radius:18px;padding:10px 14px;font-weight:900;letter-spacing:.2px
  }
  .pill b{display:block;font-size:18px;line-height:1.05;
    text-shadow:0 2px 0 rgba(0,0,0,.5),0 0 8px rgba(0,0,0,.25)}
  .pill small{opacity:.95}
  #sc{color:var(--c-score)} #cm{color:var(--c-combo)} #bs{color:var(--c-best)}
  .bestrow{flex-basis:100%} /* 下段を1枚にしたい場合はここを使う（今回は2列のまま） */

  .card{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:rgba(0,0,0,.55);text-align:center;padding:18px;z-index:10
  }
  .btn{
    display:inline-grid;place-items:center;min-width:46px;height:46px;border-radius:18px;
    padding:0 18px;background:var(--accent);color:#222;font-weight:900;font-size:18px;
    box-shadow:0 4px 0 #caa132;border:0
  }

  /* スタート画面：スーファミっぽく影強め */
  .title{font-size:34px;font-weight:900;letter-spacing:.6px;margin-bottom:8px;
         text-shadow:0 3px 0 rgba(0,0,0,.6),0 0 14px rgba(0,0,0,.25)}
  .lead{font-size:20px;margin:.6em 0 1.0em 0;text-shadow:0 2px 0 rgba(0,0,0,.5)}
  .desc{font-size:18px;opacity:.98;text-shadow:0 2px 0 rgba(0,0,0,.5)}
</style>

<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill"><b id="sc">Score 0</b><small id="scsub">&nbsp;</small></div>
  <div class="pill"><b id="cm">Combo 0</b><small id="cmsub">&nbsp;</small></div>
  <div class="pill"><b id="bs">Best 0</b><small id="lvl">/ Lv.1</small></div>
</div>

<div class="card" id="start">
  <div class="title">レッツ！ピンポン！！</div>
  <div class="lead">ラリーを楽しもう</div>
  <div class="desc">円が重なる瞬間に <b>TAP!</b></div>
  <div class="desc" style="margin-bottom:16px">
    Perfect / Great / Good で加点＆コンボ。<br>90秒で<strong>激ムズ</strong>モード。
  </div>
  <button id="go" class="btn">スタート</button>
</div>

<div class="card" id="over" style="display:none">
  <!-- 2段固定 -->
  <div id="final" style="font-size:24px;margin-bottom:10px;text-shadow:0 3px 0 rgba(0,0,0,.55)">
    Score 0<br>Lv.1
  </div>
  <button id="retry" class="btn">もう一回</button>
</div>

<script>
(()=>{
/* ===== 画像（指定名） ===== */
const BG_URL     = './F0BDAD6E-3A4B-49E8-86BF-73CE3EAA6C58.png'; // 台なし背景
const FG_URL     = './IMG_4406.png';                              // 台＋ネット前景
const OPP_IDLE   = './IMG_4414.png';
const OPP_SWING  = './IMG_4413.png';
const OPP_FOLLOW = './IMG_4412.png';

/* ===== 物理・表示パラメータ（据え置き） ===== */
const NET_Y=0.595, Y_PLAYER=0.115, Y_OPP=0.085, X_MARGIN=0.16, Y_JIT=0.018;
const START_DUR=1.00, SPEEDUP_EVERY=2, SPEEDUP_RATE=0.93, MIN_DUR=0.46;

const RING_BASE=28, RING_SHRINK=36;
const TOL_DIST_GOOD=36, TOL_DIST_GREAT=22, TOL_DIST_PERF=12;
const TOL_TIME_GOOD=12, TOL_TIME_GREAT=7, TOL_TIME_PERF=3;
const SCORE_BASE=100, MULT_GOOD=1.00, MULT_GREAT=1.30, MULT_PERF=1.60;
const COMBO_BONUS=0.15, DEMON_AT=90;

const ARC_H=0.12, CURVE_X=0.10;

/* スケール据え置き */
const BG_DES_W=768, BG_DES_H=1152;
let FG_SCALE=0.92, FG_Y_OFFSET=0;
const OPP_BASE_SCALE=0.58*1.35, OPP_FOOT_Y=0.565;
const BALL_FRONT=true;

/* ネット透け封じ（天板色の帯） */
const OCCLUDER={enabled:true,color:'#1b4d74',alpha:1.0,height:0.115,offsetY:-0.004};

/* ===== Canvas ===== */
const cv=document.getElementById('cv'), g=cv.getContext('2d');
const S=document.getElementById('start'), O=document.getElementById('over');
const go=document.getElementById('go'), retry=document.getElementById('retry');
const F=document.getElementById('final');
const sc=document.getElementById('sc'), scs=document.getElementById('scsub');
const cm=document.getElementById('cm'), cms=document.getElementById('cmsub');
const bs=document.getElementById('bs'), lvl=document.getElementById('lvl');

let W=0,H=0,dpr=1;
function fit(){ dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',fit,{passive:true}); fit();

/* ===== 画像ロード ===== */
function load(src){return new Promise(r=>{const i=new Image(); i.crossOrigin='anonymous';
  i.onload=()=>r(i); i.onerror=()=>r(null); i.src=src; });}
const A={bg:null,fg:null,oppIdle:null,oppSw:null,oppFo:null};
Promise.all([load(BG_URL),load(FG_URL),load(OPP_IDLE),load(OPP_SWING),load(OPP_FOLLOW)])
  .then(([a,b,c,d,e])=>{A.bg=a;A.fg=b;A.oppIdle=c;A.oppSw=d;A.oppFo=e;});

/* ===== Audio —— iOS対策付き ===== */
let AC=null, master=null, bgm={timer:null,lead:null,bass:null,lg:null,bg:null};
function ac(){
  if(!AC){
    AC=new (window.AudioContext||window.webkitAudioContext)();
    master=AC.createGain(); master.gain.value=.9; master.connect(AC.destination);
  }
  if(AC.state!=='running'){ AC.resume(); }
}
function sePock(){           // 打球SE
  ac();
  const o=AC.createOscillator(), g1=AC.createGain();
  o.type='sine'; o.frequency.setValueAtTime(1350,AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(520,AC.currentTime+0.06);
  g1.gain.setValueAtTime(0.0001,AC.currentTime);
  g1.gain.exponentialRampToValueAtTime(0.35,AC.currentTime+0.005);
  g1.gain.exponentialRampToValueAtTime(0.0001,AC.currentTime+0.12);
  o.connect(g1).connect(master); o.start(); o.stop(AC.currentTime+0.14);

  const buf=AC.createBuffer(1,AC.sampleRate*0.07,AC.sampleRate), ch=buf.getChannelData(0);
  for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.pow(1-i/ch.length,2);
  const n=AC.createBufferSource(); n.buffer=buf; const g2=AC.createGain(); g2.gain.value=0.12;
  n.connect(g2).connect(master); n.start(); n.stop(AC.currentTime+0.07);
}
function startBGM(){         // 8bit風ループ（確実に鳴るリアルタイム更新）
  ac(); stopBGM();
  const leadSeq=[0,2,4,5,7,5,4,2];       // スケール度数
  const baseA=440, bassDiv=4;
  const tempo=124;                        // BPM
  const stepMs=60000/tempo/2;            // 8分音符ごと
  bgm.lead=AC.createOscillator(); bgm.lg=AC.createGain();
  bgm.bass=AC.createOscillator(); bgm.bg=AC.createGain();
  bgm.lead.type='square'; bgm.bass.type='triangle';
  bgm.lg.gain.value=0.06; bgm.bg.gain.value=0.05;
  bgm.lead.connect(bgm.lg).connect(master);
  bgm.bass.connect(bgm.bg).connect(master);
  bgm.lead.start(); bgm.bass.start();
  let k=0;
  bgm.timer=setInterval(()=>{
    if(AC.state!=='running') AC.resume();
    const deg=leadSeq[k%leadSeq.length];
    const fLead=baseA*Math.pow(2,deg/12);
    const fBass=baseA/bassDiv*Math.pow(2,((k%4)*2)/12);
    bgm.lead.frequency.setValueAtTime(fLead, AC.currentTime);
    bgm.bass.frequency.setValueAtTime(fBass, AC.currentTime);
    k++;
  }, stepMs);
}
function stopBGM(){
  if(bgm.timer){ clearInterval(bgm.timer); bgm.timer=null; }
  ['lead','bass','lg','bg'].forEach(n=>{
    if(bgm[n]){ try{ bgm[n].stop(); }catch{} try{bgm[n].disconnect()}catch{} bgm[n]=null; }
  });
}

/* ===== 乱数・スポット ===== */
const R=Math.random, rnd=(a,b)=>a+R()*(b-a), sec=()=>performance.now()/1000;
const oppSpot=()=>({x:rnd(W*X_MARGIN,W*(1-X_MARGIN)), y:H*NET_Y-H*Y_OPP+rnd(-H*Y_JIT,H*Y_JIT)});
const plySpot=()=>({x:rnd(W*X_MARGIN,W*(1-X_MARGIN)), y:H*NET_Y+H*Y_PLAYER+rnd(-H*Y_JIT,H*Y_JIT)});

/* ===== 状態 ===== */
let playing=false, t0=0, dur=START_DUR, phase='toPlayer';
let from={x:0,y:0}, to={x:0,y:0}, ctrl={x:0,y:0};
let playerAim={x:0,y:0}, oppAim={x:0,y:0};
let score=0, combo=0, best=Number(localStorage.getItem('PT_best')||0), level=1, steps=0, startedAt=0;
let judgeText='', judgeUntil=0;
bs.textContent='Best '+best.toFixed(0);
const showJudge=t=>{judgeText=t; judgeUntil=sec()+0.85;}
const bez=(p,a,c,b)=>{const u=1-p; return u*u*a+2*u*p*c+p*p*b;}
function setLeg(a,b){ from=a;to=b;t0=sec();
  const midx=(a.x+b.x)/2, curve=(b.x-a.x)*rnd(-CURVE_X,CURVE_X);
  ctrl={x:midx+curve, y:H*NET_Y - H*ARC_H*rnd(0.85,1.15)};
}
function resetState(){
  score=0;combo=0;level=1;steps=0;dur=START_DUR;
  sc.textContent='Score 0';scs.innerHTML='&nbsp;';cm.textContent='Combo 0';cms.innerHTML='&nbsp;';
  lvl.textContent='/ Lv.1'; playerAim=plySpot(); oppAim=oppSpot(); phase='toPlayer'; startedAt=sec();
  setLeg(oppAim,playerAim); judgeText='';judgeUntil=0;
}
function startGame(){ ac(); startBGM(); resetState(); S.style.display='none'; O.style.display='none'; playing=true; }
function gameOver(){
  playing=false; stopBGM();
  if(score>best){best=score;localStorage.setItem('PT_best',best);}
  bs.textContent='Best '+best.toFixed(0);
  F.innerHTML='Score '+score.toFixed(0)+'<br>Lv.'+level;  // 2段
  O.style.display='flex';
}

/* ===== 入力 ===== */
addEventListener('pointerdown', e=>{
  ac(); // iOS: どのタップでもContextを走らせる
  if(!playing||phase!=='toPlayer') return;
  const r=cv.getBoundingClientRect(); const x=(e.clientX??e.touches?.[0]?.clientX)-r.left;
  const y=(e.clientY??e.touches?.[0]?.clientY)-r.top;
  const rr=ringRadiusNow(), dt=Math.abs(rr-RING_BASE), d=Math.hypot(x-playerAim.x,y-playerAim.y);
  let mult=0, tag='';
  if(dt<=TOL_TIME_PERF && d<=TOL_DIST_PERF){mult=MULT_PERF;tag='Perfect!';}
  else if(dt<=TOL_TIME_GREAT && d<=TOL_DIST_GREAT){mult=MULT_GREAT;tag='Great!';}
  else if(dt<=TOL_TIME_GOOD && d<=TOL_DIST_GOOD){mult=MULT_GOOD;tag='Good!';}
  if(mult>0){
    sePock();
    const add=Math.round(SCORE_BASE*mult*(1+combo*COMBO_BONUS));
    score+=add;combo++;steps++;sc.textContent='Score '+score.toFixed(0);scs.textContent='+'+add;
    cm.textContent='Combo '+combo;cms.textContent=tag;showJudge(tag);
    if(steps%SPEEDUP_EVERY===0){ const rate=(sec()-startedAt>=DEMON_AT)?0.90:SPEEDUP_RATE;
      dur=Math.max(MIN_DUR,dur*rate); level++; lvl.textContent='/ Lv.'+level; }
    phase='toOpponent'; oppAim=oppSpot(); setLeg(playerAim,oppAim);
  }else{cms.textContent='Miss!';showJudge('Miss!');gameOver();}
},{passive:true});

function ringRadiusNow(){ const p=Math.min(1,Math.max(0,(sec()-t0)/dur));
  return RING_BASE+RING_SHRINK*((phase==='toPlayer')?(1-p):1); }

/* ===== ループ ===== */
let last=sec();
function loop(){
  const now=sec(); last=now;

  // 背景
  if(A.bg){ const r=Math.max(W/A.bg.width,H/A.bg.height), w=A.bg.width*r, h=A.bg.height*r;
    g.drawImage(A.bg,(W-w)/2,(H-h)/2,w,h);
  }else{ const grad=g.createLinearGradient(0,0,0,H); grad.addColorStop(0,'#1a315d'); grad.addColorStop(1,'#0b1631');
    g.fillStyle=grad; g.fillRect(0,0,W,H); }

  // 相手（背景の上）
  drawOpponent(now);

  // ネット透け封じ帯（前景直下）
  if(OCCLUDER.enabled){
    const h=H*OCCLUDER.height, y=H*(NET_Y + OCCLUDER.offsetY) - h/2;
    g.save(); g.globalAlpha=OCCLUDER.alpha; g.fillStyle=OCCLUDER.color;
    g.fillRect(0, Math.round(y), W, Math.round(h)); g.restore();
  }

  // 台＋ネット（前景）
  drawForeground();

  // 進行・ボール（最前面）
  if(playing){
    const p=Math.min(1,(now-t0)/dur);
    const bx=bez(p,from.x,ctrl.x,to.x), by=bez(p,from.y,ctrl.y,to.y);

    if(p>=1){
      if(phase==='toPlayer'){ gameOver(); }
      else { sePock(); phase='toPlayer'; playerAim=plySpot(); setLeg(oppAim,playerAim); }
    }

    const rr=ringRadiusNow();
    drawGuide(playerAim.x,playerAim.y,rr,true,(judgeUntil>now)?judgeText:'TAP!');

    if(BALL_FRONT){
      const hNorm=1-4*(p-0.5)*(p-0.5), rad=8*(1+0.08*hNorm);
      g.globalAlpha=0.25*(1-hNorm); g.fillStyle='#000';
      g.beginPath(); g.ellipse(bx+2,by+6,rad*0.9,rad*0.55,0,0,Math.PI*2); g.fill();
      g.globalAlpha=1; g.fillStyle='#fff'; g.beginPath(); g.arc(bx,by,rad,0,Math.PI*2); g.fill();
    }
  }

  // 激ムズ帯
  if(playing && (now-startedAt)>=DEMON_AT){ g.fillStyle='rgba(255,80,80,.18)'; g.fillRect(0,0,W,6); }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== 前景（台） ===== */
function drawForeground(){
  if(!A.fg) return;
  const sBase=Math.min(W/BG_DES_W,H/BG_DES_H), s=sBase*FG_SCALE;
  const w=A.fg.width*s, h=A.fg.height*s, x=Math.round((W-w)/2), y=Math.round(H-h+FG_Y_OFFSET*s);
  const keep=g.imageSmoothingEnabled; g.imageSmoothingEnabled=false;
  g.drawImage(A.fg,x,y,w,h); g.imageSmoothingEnabled=keep;
}

/* ===== 相手（3枚） ===== */
function drawOpponent(now){
  if(!A.oppIdle) return;
  const sBase=Math.min(W/BG_DES_W,H/BG_DES_H), scale=sBase*OPP_BASE_SCALE;
  const idle=A.oppIdle, sw=A.oppSw, fo=A.oppFo; let img=idle;
  if(playing && phase==='toOpponent'){ const p=Math.min(1,(now-t0)/dur);
    if(p>0.65 && p<=0.8) img=sw; else if(p>0.8 && p<=0.95) img=fo; }
  const faceRight=(oppAim.x < W*0.5), iw=img.width*scale, ih=img.height*scale;
  const cx=oppAim.x, x=cx - iw*0.5, y=H*OPP_FOOT_Y - ih;
  g.save(); if(!faceRight){ g.translate(cx,0); g.scale(-1,1); g.translate(-cx,0); }
  const keep=g.imageSmoothingEnabled; g.imageSmoothingEnabled=false;
  g.drawImage(img, faceRight?x:(2*cx - x - iw), Math.round(y), Math.round(iw), Math.round(ih));
  g.imageSmoothingEnabled=keep; g.restore();
}

/* ===== ガイド（自分だけ） ===== */
function drawGuide(x,y,rr,isPlayer,label){
  g.beginPath(); g.lineWidth=3; g.setLineDash([]);
  g.strokeStyle=isPlayer?'var(--ringP)':'var(--ringO)'; g.arc(x,y,RING_BASE,0,Math.PI*2); g.stroke();
  g.beginPath(); g.lineWidth=3; g.setLineDash(isPlayer?[6,6]:[]);
  g.strokeStyle=isPlayer?'var(--ringP)':'var(--ringO)'; g.arc(x,y,rr,0,Math.PI*2); g.stroke(); g.setLineDash([]);
  g.fillStyle=isPlayer?'#ffe38a':'#aee1ff'; g.font='900 16px system-ui'; g.textAlign='center';
  g.fillText(label, x, y-RING_BASE-10);
}

/* ===== UI ===== */
go.onclick=()=>{ startGame(); };
retry.onclick=()=>{ S.style.display='flex'; O.style.display='none'; };

/* 最初のタップで必ず音解禁 */
window.addEventListener('pointerdown', ()=>ac(), {once:true, passive:true});
})();
</script>