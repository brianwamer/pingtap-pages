<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally</title>
<style>
  :root{
    --hud-bg: rgba(20,20,30,.55);
    --ringP: rgba(255,235,150,.95); /* player */
    --ringO: rgba(170,220,255,.92); /* opponent */
    --accent:#ffd34d;
  }
  html,body{margin:0;height:100%;background:#091427;color:#fff;
    font-family:-apple-system,BlinkMacSystemFont,"Noto Sans JP",sans-serif}
  #cv{position:fixed;inset:0;touch-action:manipulation}
  .hud{position:fixed;left:10px;right:10px;top:calc(10px + env(safe-area-inset-top,0px));
       display:flex;gap:12px;z-index:3;pointer-events:none}
  .pill{min-width:120px;background:var(--hud-bg);backdrop-filter: blur(2px);
        border-radius:18px;padding:10px 14px;font-weight:800;letter-spacing:.2px}
  .pill b{display:block;font-size:16px}.pill small{opacity:.9}
  .card{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
        background:rgba(0,0,0,.55);text-align:center;padding:18px;z-index:4}
  .btn{display:inline-grid;place-items:center;min-width:46px;height:42px;border-radius:18px;
       padding:0 16px;background:var(--accent);color:#222;font-weight:800;
       box-shadow:0 4px 0 #caa132;border:0}
</style>

<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill" style="flex:1"><b id="sc">Score 0</b><small id="scsub">&nbsp;</small></div>
  <div class="pill" style="flex:1"><b id="cm">Combo 0</b><small id="cmsub">&nbsp;</small></div>
  <div class="pill" style="flex:1"><b id="bs">Best 0</b><small id="lvl">/ Lv.1</small></div>
</div>

<div class="card" id="start">
  <div style="font-size:26px;margin-bottom:8px">PingTap — Retro Rally</div>
  <div style="opacity:.9;margin-bottom:12px">円が重なる瞬間にTAP。相手→自分→相手とピン球が往復。</div>
  <div style="opacity:.9;margin-bottom:16px">Perfect/Great/Goodで加点＆コンボ。90秒で鬼モード。</div>
  <button id="go" class="btn" style="font-size:16px">スタート</button>
</div>

<div class="card" id="over" style="display:none">
  <div id="final" style="font-size:20px;margin-bottom:10px">Score 0 / Lv.1</div>
  <button id="retry" class="btn">もう一回</button>
</div>

<script>
(()=>{
/* ====== 画像ファイル名（そのまま置いてね） ====== */
const IMG_BG   = 'F0BDAD6E-3A4B-49E8-86BF-73CE3EAA6C58.png'; // 背景（台なし）
const IMG_FG   = 'IMG_4406.png';                              // 台＋ネット（前景）
const IMG_IDLE = 'IMG_4414.png';                              // 相手 Idle
const IMG_SWNG = 'IMG_4413.png';                              // 相手 Swing(インパクト)
const IMG_FOLL = 'IMG_4412.png';                              // 相手 Follow
const IMG_PD3  = 'paddle3.png';                               // (任意) 自分ラケット3コマ

/* ====== チューニング ====== */
const NET_Y      = 0.595;
const Y_PLAYER   = 0.115;
const Y_OPP      = 0.085;
const X_MARGIN   = 0.16;
const Y_JIT      = 0.018;
const START_DUR  = 1.00;
const SPEEDUP_EVERY = 2;
const SPEEDUP_RATE  = 0.93;
const MIN_DUR    = 0.46;

/* 判定とスコア */
const RING_BASE=28, RING_SHRINK=36;
const TOL_DIST_GOOD = 36, TOL_DIST_GREAT = 22, TOL_DIST_PERF = 12;
const TOL_TIME_GOOD = 12, TOL_TIME_GREAT = 7,  TOL_TIME_PERF  = 3;
const SCORE_BASE=100, MULT_GOOD=1.00, MULT_GREAT=1.30, MULT_PERF=1.60;
const COMBO_BONUS=0.15;
const DEMON_AT=90, HARD_END=120;

/* 軌道（2次ベジェ） */
const ARC_H   = 0.12;
const CURVE_X = 0.10;

/* 相手と自分ラケット表示 */
const OPP_ANCHOR_Y = 0.56, OPP_SCALE = 0.42;
const PAD_SCALE    = 0.26, PAD_OFFSET_Y = 14;

/* BGM: オリジナル（ノリ良し） */
const BGM_ENABLE = true;

/* ====== DOM/Canvas ====== */
const cv=document.getElementById('cv'), g=cv.getContext('2d');
const S=document.getElementById('start'), O=document.getElementById('over');
const go=document.getElementById('go'), retry=document.getElementById('retry');
const F=document.getElementById('final');
const sc=document.getElementById('sc'), scs=document.getElementById('scsub');
const cm=document.getElementById('cm'), cms=document.getElementById('cmsub');
const bs=document.getElementById('bs'), lvl=document.getElementById('lvl');

let W=0,H=0,dpr=1;
function fit(){ dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',fit,{passive:true}); fit();

/* ====== 画像ロード ====== */
const ASSETS={bg:null, fg:null, idle:null, swing:null, follow:null, pad:null};
function loadImg(src){ return new Promise(res=>{ const i=new Image(); i.src=src; i.onload=()=>res(i); i.onerror=()=>res(null); }); }
Promise.all([loadImg(IMG_BG),loadImg(IMG_FG),loadImg(IMG_IDLE),loadImg(IMG_SWNG),loadImg(IMG_FOLL),loadImg(IMG_PD3)])
  .then(([bg,fg,idl,sw,fl,pd])=>{ ASSETS.bg=bg; ASSETS.fg=fg; ASSETS.idle=idl; ASSETS.swing=sw; ASSETS.follow=fl; ASSETS.pad=pd; });

/* ====== WebAudio（SE + BGM） ====== */
let AC=null, master=null, bgmBus=null;
const sec = ()=>performance.now()/1000;
function ac(){ if(AC) return; AC=new (window.AudioContext||window.webkitAudioContext)();
  master=AC.createGain(); master.gain.value=.9; master.connect(AC.destination);
  bgmBus=AC.createGain(); bgmBus.gain.value=0.11; bgmBus.connect(master);
}
function sePock(){
  ac();
  const o=AC.createOscillator(), g1=AC.createGain();
  o.type='sine'; o.frequency.setValueAtTime(1350,AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(500,AC.currentTime+0.06);
  g1.gain.setValueAtTime(0.0001,AC.currentTime);
  g1.gain.exponentialRampToValueAtTime(0.35,AC.currentTime+0.005);
  g1.gain.exponentialRampToValueAtTime(0.0001,AC.currentTime+0.12);
  o.connect(g1).connect(master); o.start(); o.stop(AC.currentTime+0.14);
  const buf=AC.createBuffer(1,AC.sampleRate*0.07,AC.sampleRate);
  const ch=buf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.pow(1-i/ch.length,2);
  const n=AC.createBufferSource(); n.buffer=buf; const g2=AC.createGain(); g2.gain.value=0.12;
  n.connect(g2).connect(master); n.start(); n.stop(AC.currentTime+0.07);
}
/* --- オリジナルBGM：124BPM, 4つ打ち＋ベース＋コード＋アルペジオ --- */
let bgmStarted=false;
function oscAt(t,type,f,vol,decay,detune=0){
  const o=AC.createOscillator(), g=AC.createGain();
  o.type=type; o.frequency.value=f; o.detune.value=detune;
  g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.0001, t+decay);
  o.connect(g).connect(bgmBus); o.start(t); o.stop(t+decay*1.2);
}
function noiseAt(t,vol,decay,band=null){
  const dur=decay; const b=AC.createBuffer(1,AC.sampleRate*dur,AC.sampleRate);
  const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  const s=AC.createBufferSource(); s.buffer=b;
  let node=s;
  if(band){ const f=AC.createBiquadFilter(); f.type='bandpass'; f.frequency.value=band; f.Q.value=0.6; node=node.connect(f); }
  const g=AC.createGain(); g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.0001,t+decay);
  node.connect(g).connect(bgmBus); s.start(t); s.stop(t+dur);
}
function startBGM(){
  if(bgmStarted) return; if(!BGM_ENABLE) return;
  ac(); bgmStarted=true;
  const bpm=124, qn=60/bpm, t0=AC.currentTime+0.05;
  const bass=[55,41.2,65.4,49]; // A1,E1,C2,G1
  const chord=[220,164.8,261.6,196]; // A4,E4,C5,G4（上物）
  for(let bar=0; bar<96; bar++){
    const baseBeat=bar*4;
    // ドラム
    for(let b=0;b<4;b++){
      const t=t0+(baseBeat+b)*qn;
      oscAt(t,'triangle',55,0.6,0.18);                  // Kick
      if(b===1||b===3) noiseAt(t,0.4,0.14,1800);        // Snare(2,4)
      for(let hh=0; hh<2; hh++){ noiseAt(t+hh*qn*0.5,0.18,0.06,6000); } // Hihat 8分
    }
    // ベース（8分）
    const bf=bass[bar%bass.length];
    for(let i=0;i<8;i++){
      const t=t0+(baseBeat+i*0.5)*qn;
      oscAt(t,'square',bf*(i%2?1:2),0.14,0.20, (i%2?4:-4));
    }
    // コード・アルペジオ（表拍）
    const cf=chord[bar%chord.length];
    for(let i=0;i<4;i++){
      const t=t0+(baseBeat+i)*qn;
      oscAt(t,'sawtooth',cf,0.06,0.40, +7);
      oscAt(t+0.25*qn,'square',cf*1.5,0.05,0.20,-7); // ちょい跳ね
    }
    // 短いメロ（2小節ごと）
    if(bar%2===0){
      const t=t0+(baseBeat+1.5)*qn;
      oscAt(t,'square',440,0.08,0.18,0);
      oscAt(t+0.25*qn,'square',494,0.07,0.16,0);
      oscAt(t+0.5*qn,'square',523,0.07,0.22,0);
    }
  }
}
function stopBGM(){ if(!AC||!bgmBus) return; bgmBus.gain.setTargetAtTime(0, AC.currentTime, 0.05); }

/* ====== 乱数と打点 ====== */
const R=Math.random, rnd=(a,b)=>a+R()*(b-a);
const oppSpot =()=>({ x:rnd(W*X_MARGIN,W*(1-X_MARGIN)),
  y:H*NET_Y - H*Y_OPP + rnd(-H*Y_JIT,H*Y_JIT) });
const plySpot =()=>({ x:rnd(W*X_MARGIN,W*(1-X_MARGIN)),
  y:H*NET_Y + H*Y_PLAYER + rnd(-H*Y_JIT,H*Y_JIT) });

/* ====== ゲーム状態 ====== */
let playing=false, t0=0, dur=START_DUR, phase='toPlayer';
let from={x:0,y:0}, to={x:0,y:0}, ctrl={x:0,y:0};
let playerAim={x:0,y:0}, oppAim={x:0,y:0};
let score=0, combo=0, best=Number(localStorage.getItem('PT_best')||0), level=1, steps=0, startedAt=0;
let judgeText='', judgeUntil=0;
bs.textContent='Best '+best.toFixed(0);

// 相手見た目
let oppPos={x:0,y:0}, oppFlip=false, oppFrame='idle', oppFrameUntil=0;
// 自分ラケット
let padFrame=0, padFrameUntil=0;

const showJudge = txt => { judgeText=txt; judgeUntil = sec()+0.85; };
const bez = (p,a,c,b)=>{ const u=1-p; return u*u*a + 2*u*p*c + p*p*b; };
function setLeg(a,b){
  from=a; to=b; t0=sec();
  const midx=(a.x+b.x)/2, curve=(b.x-a.x)*rnd(-CURVE_X,CURVE_X);
  ctrl={ x:midx+curve, y: H*NET_Y - H*ARC_H*rnd(0.85,1.15) };
}

/* ====== リセット/開始/終了 ====== */
function resetState(){
  score=0; combo=0; level=1; steps=0; dur=START_DUR;
  sc.textContent='Score 0'; scs.innerHTML='&nbsp;';
  cm.textContent='Combo 0'; cms.innerHTML='&nbsp;';
  lvl.textContent='/ Lv.1';
  playerAim=plySpot(); oppAim=oppSpot(); oppPos={x:oppAim.x,y:H*OPP_ANCHOR_Y};
  phase='toPlayer'; startedAt=sec();
  setLeg(oppAim, playerAim);
  judgeText=''; judgeUntil=0; padFrame=0; padFrameUntil=0;
}
function startGame(){
  ac(); if(BGM_ENABLE) startBGM();
  resetState(); S.style.display='none'; O.style.display='none'; playing=true;
}
function gameOver(){
  playing=false; stopBGM();
  if(score>best){ best=score; localStorage.setItem('PT_best',best); }
  bs.textContent='Best '+best.toFixed(0);
  F.textContent='Score '+score.toFixed(0)+' / Lv.'+level;
  O.style.display='flex';
}

/* ====== 入力（自分の番だけ判定） ====== */
addEventListener('pointerdown',(e)=>{
  if(!playing || phase!=='toPlayer') return;
  const r=cv.getBoundingClientRect();
  const x=(e.clientX??e.touches?.[0]?.clientX)-r.left;
  const y=(e.clientY??e.touches?.[0]?.clientY)-r.top;

  const rr = ringRadiusNow();
  const dt = Math.abs(rr - RING_BASE);
  const d  = Math.hypot(x-playerAim.x,y-playerAim.y);

  let mult=0, tag='';
  if(dt<=TOL_TIME_PERF && d<=TOL_DIST_PERF){ mult=MULT_PERF; tag='Perfect!'; }
  else if(dt<=TOL_TIME_GREAT && d<=TOL_DIST_GREAT){ mult=MULT_GREAT; tag='Great!'; }
  else if(dt<=TOL_TIME_GOOD && d<=TOL_DIST_GOOD){ mult=MULT_GOOD; tag='Good!'; }

  if(mult>0){
    sePock();
    const add=Math.round(SCORE_BASE * mult * (1 + combo*COMBO_BONUS));
    score+=add; combo++; steps++;
    sc.textContent='Score '+score.toFixed(0); scs.textContent='+'+add;
    cm.textContent='Combo '+combo; cms.textContent=tag; showJudge(tag);

    // 自分ラケットちょいアニメ
    padFrame = 1; padFrameUntil = sec()+0.08;

    if(steps % SPEEDUP_EVERY === 0){
      const elapsed = sec() - startedAt;
      const rate = (elapsed>=DEMON_AT)? 0.90 : SPEEDUP_RATE;
      dur = Math.max(MIN_DUR, dur*rate); level++; lvl.textContent='/ Lv.'+level;
    }
    phase='toOpponent';
    oppAim = oppSpot();
    setLeg(playerAim, oppAim);
  }else{
    cms.textContent='Miss!'; showJudge('Miss!'); gameOver();
  }
},{passive:true});

/* ====== 時間と半径 ====== */
function ringRadiusNow(){
  const p = Math.min(1, Math.max(0, (sec()-t0)/dur));
  const left = (phase==='toPlayer') ? (1-p) : 1;
  return RING_BASE + RING_SHRINK*left;
}

/* ====== スプライト描画 ====== */
function drawSingle(img, x, y, scale, flip){
  if(!img) return;
  const w=img.width, h=img.height;
  g.save(); g.translate(x,y); if(flip) g.scale(-1,1);
  g.drawImage(img, -w*scale*0.5, -h*scale, w*scale, h*scale);
  g.restore();
}
function drawSprite3(img, x, y, scale, frame, flip) {
  if (!img) return;
  const fw = img.width/3, fh = img.height;
  g.save();
  g.translate(x, y);
  if (flip) g.scale(-1,1);
  g.drawImage(img, fw*frame, 0, fw, fh, -fw*scale*0.5, -fh*scale, fw*scale, fh*scale);
  g.restore();
}
function drawOpponent(now){
  const aimX = oppAim?.x ?? W*0.5;
  const baseY = H*OPP_ANCHOR_Y;
  oppPos.x += (aimX - oppPos.x) * 0.18;
  oppPos.y += (baseY - oppPos.y) * 0.18;
  oppFlip = (aimX > W*0.5);

  const ms = (sec()-t0)*1000;
  if (phase==='toOpponent' && ms<120){ oppFrame='swing'; oppFrameUntil=sec()+0.12; }
  else if (phase==='toPlayer' && ms<120){ oppFrame='follow'; oppFrameUntil=sec()+0.12; }
  else if (sec()>oppFrameUntil){ oppFrame='idle'; }

  const img = oppFrame==='swing' ? ASSETS.swing : oppFrame==='follow' ? ASSETS.follow : ASSETS.idle;
  drawSingle(img, oppPos.x, oppPos.y, OPP_SCALE, oppFlip);
}
function drawPlayerPaddle(){
  const now=sec();
  if (ASSETS.pad){
    if (now>padFrameUntil){
      if (padFrame===1){ padFrame=2; padFrameUntil=now+0.09; } else padFrame=0;
    }
    drawSprite3(ASSETS.pad, playerAim.x, playerAim.y+PAD_OFFSET_Y, PAD_SCALE, padFrame, false);
  }else{
    g.fillStyle='#d33';
    g.beginPath(); g.arc(playerAim.x, playerAim.y+PAD_OFFSET_Y, 14, 0, Math.PI*2); g.fill();
    g.strokeStyle='#822'; g.lineWidth=3; g.stroke();
  }
}

/* ====== ループ ====== */
let last = sec();
function loop(){
  const now = sec(); last = now;

  // 背景（台なし）
  if(ASSETS.bg){
    const r=Math.max(W/ASSETS.bg.width,H/ASSETS.bg.height);
    const w=ASSETS.bg.width*r, h=ASSETS.bg.height*r;
    g.drawImage(ASSETS.bg,(W-w)/2,(H-h)/2,w,h);
  }

  // 相手キャラ
  drawOpponent(now);

  if(playing){
    const p = Math.min(1,(now-t0)/dur);
    const bx = bez(p, from.x, ctrl.x, to.x);
    const by = bez(p, from.y, ctrl.y, to.y);

    if(p>=1){
      if(phase==='toPlayer'){ gameOver(); }
      else { phase='toPlayer'; playerAim = plySpot(); setLeg(oppAim, playerAim); }
    }

    drawGuide(oppAim.x,oppAim.y,RING_BASE,false,'HIT!');
    const rr = ringRadiusNow();
    drawGuide(playerAim.x,playerAim.y,rr,true,(judgeUntil>now)?judgeText:'TAP!');

    drawPlayerPaddle();

    const hNorm = 1 - 4*(p-0.5)*(p-0.5), rad = 8 * (1 + 0.08*hNorm);
    g.globalAlpha = 0.25*(1-hNorm);
    g.fillStyle='#000'; g.beginPath(); g.ellipse(bx+2, by+6, rad*0.9, rad*0.55, 0, 0, Math.PI*2); g.fill();
    g.globalAlpha = 1;
    g.fillStyle='#fff'; g.beginPath(); g.arc(bx,by,rad,0,Math.PI*2); g.fill();
  }

  // 台＋ネット（前景）
  if(ASSETS.fg){
    const r=Math.max(W/ASSETS.fg.width,H/ASSETS.fg.height);
    const w=ASSETS.fg.width*r, h=ASSETS.fg.height*r;
    g.drawImage(ASSETS.fg,(W-w)/2,(H-h)/2,w,h);
  }

  if(playing && (now - startedAt)>=DEMON_AT){
    g.fillStyle='rgba(255,80,80,.18)'; g.fillRect(0,0,W,6);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== 描画ユーティリティ ====== */
function drawGuide(x,y,rr,isPlayer,label){
  g.beginPath(); g.lineWidth=3; g.setLineDash([]);
  g.strokeStyle = isPlayer? 'var(--ringP)':'var(--ringO)';
  g.arc(x,y,RING_BASE,0,Math.PI*2); g.stroke();

  g.beginPath(); g.lineWidth=3; g.setLineDash(isPlayer?[6,6]:[]);
  g.strokeStyle = isPlayer? 'var(--ringP)':'var(--ringO)';
  g.arc(x,y,rr,0,Math.PI*2); g.stroke(); g.setLineDash([]);

  g.fillStyle = isPlayer?'#ffe38a':'#aee1ff';
  g.font='700 14px system-ui'; g.textAlign='center';
  g.fillText(label, x, y-RING_BASE-10);
}

/* ====== ボタン ====== */
go.onclick=startGame;
retry.onclick=()=>{ S.style.display='flex'; O.style.display='none'; };
})();
</script>