<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>PingTap — Retro Rally</title>
<style>
  :root{
    --hud-gap:10px;
    --cap-bg: rgba(0,0,0,.35);
    --cap-blur: saturate(120%) blur(6px);
    --accent:#ffd14a;
  }
  html,body{height:100%;margin:0;background:#0b1224;color:#fff;font:16px/1.6 system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue","Hiragino Sans",Meiryo,sans-serif;}
  /* 背景固定＋フォールバック */
  .stage{
    position:fixed; inset:0;
    background: #0b1224 url("./2FE72969-9374-4D85-ADBC-28EADEE8437A.png?v=3") center/cover no-repeat;
  }
  .stage.fallback{ background:#0b1224; }
  .shade{position:fixed; inset:0; background: radial-gradient(120% 120% at 50% 20%, transparent 60%, rgba(0,0,0,.45)); pointer-events:none;}
  canvas{position:fixed; inset:0; touch-action:manipulation;}
  /* HUD（Score / Combo | spacer | Best | Pause） */
  .hud{
    position:fixed;
    top:calc(env(safe-area-inset-top,0px) + 6px);
    left:calc(env(safe-area-inset-left,0px) + 8px);
    right:calc(env(safe-area-inset-right,0px) + 8px);
    display:grid; grid-template-columns:auto auto 1fr auto auto; gap:var(--hud-gap);
    align-items:center; z-index:10; pointer-events:none;
  }
  .cap{
    background:var(--cap-bg); backdrop-filter:var(--cap-blur);
    color:#fff; font-weight:700; padding:8px 14px; border-radius:20px; white-space:nowrap; line-height:1;
    text-shadow:0 1px 0 rgba(0,0,0,.35);
  }
  .spacer{min-width:6px}
  .btn{pointer-events:auto; cursor:pointer; user-select:none; border:0; font:inherit; color:#fff}
  .btn.pill{background:var(--cap-bg); backdrop-filter:var(--cap-blur); padding:8px 14px; border-radius:20px;}
  /* 中央メッセージ＆ボタン */
  .center{
    position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:9;
  }
  .center .msg{ pointer-events:auto; text-align:center; }
  .big{ font-size:28px; font-weight:800; text-shadow:0 2px 0 rgba(0,0,0,.5); }
  .btn.main{ background:var(--accent); color:#221; padding:12px 22px; border-radius:14px; margin-top:12px; }
  /* ポーズメニュー */
  .overlay{ position:fixed; inset:0; display:none; place-items:center; z-index:20; }
  .overlay.show{ display:grid; }
  .panel{
    background:rgba(10,12,20,.9); backdrop-filter:blur(10px);
    border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:16px; width:min(92vw,420px);
  }
  .panel h2{margin:0 0 12px; font-size:18px}
  .row{display:flex; gap:10px; flex-wrap:wrap}
  .row .btn{background:#243048; padding:10px 14px; border-radius:10px}
  .note{opacity:.75; font-size:12px; margin-top:8px}
  /* タップガイド */
  .guide{ position:fixed; left:0; top:0; pointer-events:none; z-index:8 }
  .hint{ position:absolute; transform:translate(-50%,-50%); text-align:center; color:#ffe07a; font-weight:800; letter-spacing:.03em }
  .ring{ width:1px; height:1px; border-radius:999px; border:3px dashed #ffd96b; box-shadow:0 0 0 3px rgba(255,217,107,.25) inset, 0 0 18px rgba(255,217,107,.25); }
  .dot{ width:10px; height:10px; background:#ffe07a; border-radius:999px; margin:10px auto 0 }
  /* フッターメモ（非タップ要素） */
  .foot{position:fixed; left:0; right:0; bottom:calc(env(safe-area-inset-bottom,0px)+6px); text-align:center; font-size:12px; opacity:.65; pointer-events:none}
</style>

<div class="stage" id="bg"></div>
<div class="shade"></div>
<canvas id="cv"></canvas>

<!-- HUD -->
<div class="hud">
  <div id="score" class="cap">Score 0</div>
  <div id="combo" class="cap">Combo 0</div>
  <div class="spacer"></div>
  <div id="best"  class="cap">Best 0 / Lv.1</div>
  <button id="pause" class="btn pill" aria-label="Pause">II</button>
</div>

<!-- タップガイド -->
<div class="guide" id="guide">
  <div class="hint" id="hint" style="left:-9999px; top:-9999px">
    <div id="hintText">TAP!</div>
    <div class="ring" id="ring"></div>
    <div class="dot"></div>
  </div>
</div>

<!-- 中央メッセージ -->
<div class="center" id="center">
  <div class="msg">
    <div class="big" id="centerText">PingTap — Retro Rally</div>
    <button id="startBtn" class="btn main">スタート</button>
  </div>
</div>

<!-- ポーズメニュー -->
<div class="overlay" id="menu">
  <div class="panel">
    <h2>Pause</h2>
    <div class="row">
      <button class="btn" id="resumeBtn">▶ 再開</button>
      <button class="btn" id="restartBtn">↻ リスタート</button>
      <button class="btn" id="bgmBtn">♪ BGM ON/OFF</button>
    </div>
    <div class="note">中断時や着信でも崩れないよう状態を保持します。</div>
  </div>
</div>

<div class="foot">※ ラリーは最大90秒で鬼加速。Good/Great/Perfectで加点＆コンボ。</div>

<script>
/* ========= 基本パラメータ（ここ触れば全体のチューニング可） ========= */
const CFG = {
  TARGET_Y_FRAC: 0.63,          // ターゲットの高さ（画面高に対する比率） → 白丸より少し上
  PLAYER_X_RANGE: 0.32,         // こちら側Xランダム幅（中心±）
  ENEMY_X_RANGE: 0.38,          // 相手側Xランダム幅（演出用）
  RING_BASE: 58,                // 基本リング半径(px)
  TOL_GOOD: 22,                 // 時間誤差（Good）
  TOL_GREAT: 14,                // Great
  TOL_PERF: 8,                  // Perfect
  SPEED_MS_START: 1150,         // 最初の1回あたりの尺
  SPEED_MS_END: 450,            // 90秒到達時の尺
  HITS_TO_MAX: 70,              // ここまでに最大難度到達（≈ 70ヒット ≈ 90sec想定）
  POST_90_ACCEL: 0.85,          // 90秒以降の鬼加速係数（連打ごとに掛ける）
  BALL_ARC_H: 0.12,             // ボールの弧の高さ（画面高比）
  SFX_VOL: 0.35,                // SFX音量
};
/* ============================================================= */

const cv = document.getElementById('cv'), g = cv.getContext('2d');
const guide = document.getElementById('guide'), hint = document.getElementById('hint'),
      ringEl = document.getElementById('ring'), hintText = document.getElementById('hintText');
const center = document.getElementById('center'), centerText = document.getElementById('centerText'), startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score'), comboEl = document.getElementById('combo'), bestEl = document.getElementById('best');
const pauseBtn = document.getElementById('pause'), menu = document.getElementById('menu'),
      resumeBtn = document.getElementById('resumeBtn'), restartBtn = document.getElementById('restartBtn'), bgmBtn = document.getElementById('bgmBtn');

let W=0,H=0, DPR=1, RAF=0, now=0, last=0;

let state='idle';
let round=0, score=0, best=Number(localStorage.getItem('pingtap_best')||0)|0, combo=0, level=1;
let ring={x:0,y:0, r:CFG.RING_BASE, rMax:CFG.RING_BASE, t:0, dur:CFG.SPEED_MS_START};
let ball=null, travel=null; // ball:{x,y}, travel:{sx,sy,ex,ey,t,dur}
let post90=1;

function rs(){ // リサイズ
  DPR = Math.min(2, (window.devicePixelRatio||1));
  W = cv.width = Math.floor(innerWidth*DPR);
  H = cv.height= Math.floor(innerHeight*DPR);
  cv.style.width = innerWidth+'px'; cv.style.height = innerHeight+'px';
  guide.style.width = innerWidth+'px'; guide.style.height = innerHeight+'px';
}
addEventListener('resize', rs, {passive:true}); rs();

/* 背景フォールバック */
(() => {
  const img=new Image();
  img.onload=()=>{}; img.onerror=()=>document.getElementById('bg').classList.add('fallback');
  img.src="./2FE72969-9374-4D85-ADBC-28EADEE8437A.png?v=3";
})();

/* ==== WebAudio（SFX + 16bit風BGM） ==== */
const AC = new (window.AudioContext||window.webkitAudioContext)();
let bgmSeq=null, bgmOn=false;
function sTap(kind='good'){
  const t=AC.currentTime, v=AC.createGain(); v.gain.value=CFG.SFX_VOL; v.connect(AC.destination);
  const osc=AC.createOscillator(); osc.type='square';
  const base = kind==='perfect'? 880 : kind==='great'? 740 : 660;
  osc.frequency.setValueAtTime(base, t);
  osc.frequency.exponentialRampToValueAtTime(base*0.7, t+0.06);
  v.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
  osc.connect(v); osc.start(); osc.stop(t+0.09);
}
function sMiss(){
  const t=AC.currentTime, v=AC.createGain(); v.gain.value=CFG.SFX_VOL*0.9; v.connect(AC.destination);
  const o1=AC.createOscillator(); o1.type='triangle'; o1.frequency.setValueAtTime(240, t);
  const o2=AC.createOscillator(); o2.type='triangle'; o2.frequency.setValueAtTime(180, t);
  v.gain.exponentialRampToValueAtTime(0.0001, t+0.4);
  o1.connect(v); o2.connect(v); o1.start(); o2.start(); o1.stop(t+0.41); o2.stop(t+0.41);
}
function startBGM(){
  if(bgmSeq){ return; }
  const m=AC.createGain(); m.gain.value=0.18; m.connect(AC.destination);
  // 簡易2chループ（スーファミ風アルペジオ）
  function ch(type,notes,tempo=110){
    let g=AC.createGain(); g.gain.value=0.8; g.connect(m);
    let o=AC.createOscillator(); o.type=type; o.connect(g);
    let t=AC.currentTime + 0.02;
    const sp=60/tempo; // 秒/拍
    for(let i=0;i<128;i++){
      const n = notes[i%notes.length];
      const f = 440*Math.pow(2,(n-69)/12); // MIDI→Hz
      o.frequency.setValueAtTime(f, t);
      g.gain.setValueAtTime(0.9, t);
      g.gain.exponentialRampToValueAtTime(0.001, t+sp*0.8);
      t+=sp;
    }
    o.start(); return {o,g};
  }
  const lead = ch('square',[76,79,83,79,76,79,83,79], 112);
  const bass = ch('triangle',[40,40,43,40,35,35,38,35], 56);
  bgmSeq = {m, lead, bass};
  bgmOn = true;
}
function stopBGM(){
  if(!bgmSeq) return;
  ['lead','bass'].forEach(k=>{
    try{ bgmSeq[k].o.stop(); }catch{}
  });
  bgmSeq.m.disconnect();
  bgmSeq=null; bgmOn=false;
}

/* ==== ゲーム状態 ==== */
function resetAll(){
  cancelAnimationFrame(RAF);
  RAF=0; score=0; combo=0; level=1; post90=1;
  round=0; ball=null; travel=null;
  ring.r = ring.rMax = CFG.RING_BASE;
  ring.t = 0; ring.dur = CFG.SPEED_MS_START;
  updateHUD();
  center.classList.remove('hide');
  center.style.display='grid';
  centerText.textContent = 'Score 0 / Lv.1';
  startBtn.textContent = 'もう一回';
  state='idle';
  placeNextTarget(); // 先に置いておく
  draw();
}
function updateHUD(){
  scoreEl.textContent = `Score ${score|0}`;
  comboEl.textContent = `Combo ${combo|0}`;
  bestEl.textContent  = `Best ${Math.max(best,score)|0} / Lv.${level|0}`;
}

function easeInOut(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

function placeNextTarget(){
  const cx = innerWidth*0.5;
  const x = cx + (Math.random()*2-1)*innerWidth*CFG.PLAYER_X_RANGE*0.5;
  const y = innerHeight*CFG.TARGET_Y_FRAC;
  ring.x=x; ring.y=y; ring.r=ring.rMax=CFG.RING_BASE; ring.t=0;
  hint.style.left = x+'px'; hint.style.top = y+'px';
  ringEl.style.width = ring.r*2+'px'; ringEl.style.height= ring.r*2+'px';
}

function scheduleEnemyReturn(){
  // 敵コートへ飛ばし → ランダムXでこちらに返す（弧で描画）
  const sx = ring.x, sy = ring.y;
  const ex = innerWidth*0.5 + (Math.random()*2-1)*innerWidth*CFG.ENEMY_X_RANGE*0.5;
  const ey = innerHeight*0.28; // 相手側の打点
  // プレイヤー側へ戻す着地点＝次のリング位置（既にplaceNextTargetで決める）
  const nx = ring.x, ny = ring.y;
  const T = Math.max(350, ring.dur*0.6);
  travel = {phase:0, sx,sy, ex,ey, nx,ny, t:0, dur:T};
  ball = {x:sx, y:sy};
}

function commitHit(grade){
  // スコア
  const add = grade==='perfect'? 300 : grade==='great'? 200 : 120;
  combo++; const mult = 1 + Math.min(2, combo*0.04);
  score += Math.round(add*mult);
  if(score>best){ best=score; localStorage.setItem('pingtap_best', best|0); }
  // スピード更新（45–90秒域で上がる想定）
  round++;
  const p = Math.min(1, round/CFG.HITS_TO_MAX);
  ring.dur = CFG.SPEED_MS_START + (CFG.SPEED_MS_END-CFG.SPEED_MS_START)*p;
  if(p>=1){ ring.dur = Math.max(300, ring.dur*CFG.POST_90_ACCEL**(round-CFG.HITS_TO_MAX)); }
  level = 1 + Math.floor(round/10);
  updateHUD();
  sTap(grade);
  // 返球→敵→戻りをスケジュール
  scheduleEnemyReturn();
}

function miss(){
  sMiss();
  state='over';
  center.style.display='grid';
  centerText.textContent = `Score ${score|0} / Lv.${level|0}`;
  startBtn.textContent='もう一回';
  combo=0;
  updateHUD();
}

function tap(e){
  if(state==='idle'){ // 開始
    AC.resume().catch(()=>{});
    center.style.display='none';
    state='play';
    last=performance.now();
    if(!RAF) RAF=requestAnimationFrame(loop);
    return;
  }
  if(state!=='play') return;

  // タイミング判定：リングが縮む進捗（0→dur）
  const tErr = Math.abs(ring.t - ring.dur*0.5); // ちょうど半径=R/2あたりを基準に
  let grade=null;
  if(tErr<=CFG.TOL_PERF) grade='perfect';
  else if(tErr<=CFG.TOL_GREAT) grade='great';
  else if(tErr<=CFG.TOL_GOOD) grade='good';
  else return miss();

  commitHit(grade);
  // 次ターゲットは先に決めておき、返球演出後にそのまま流れ込む
  placeNextTarget();
}

function loop(ts){
  RAF=requestAnimationFrame(loop);
  now=ts; const dt=now-last; last=now;
  update(dt); draw();
}

function update(dt){
  if(state!=='play') return;
  // ボール移動（演出）
  if(travel){
    const T=travel; T.t+=dt;
    const u=Math.min(1,T.t/T.dur), v=easeInOut(u);
    // フェーズ0: こちら→相手, 1: 相手→こちら
    if(T.phase===0){
      const h=innerHeight*CFG.BALL_ARC_H;
      ball.x = T.sx + (T.ex-T.sx)*v;
      ball.y = (T.sy + (T.ey-T.sy)*v) - Math.sin(Math.PI*v)*h;
      if(u>=1){ T.phase=1; T.t=0; }
    }else{
      const h=innerHeight*CFG.BALL_ARC_H;
      ball.x = T.ex + (T.nx-T.ex)*v;
      ball.y = (T.ey + (T.ny-T.ey)*v) - Math.sin(Math.PI*v)*h;
      if(u>=1){ travel=null; } // 次のリング進行へ
    }
  }else{
    // リング縮小（タイミング）
    ring.t += dt;
    const prog = Math.min(1, ring.t / ring.dur);
    ring.r = ring.rMax * (1 - 0.6*prog);
    ringEl.style.width = (ring.r*2)+'px';
    ringEl.style.height = (ring.r*2)+'px';
    hintText.textContent = prog<0.35? 'TAP!' : prog<0.7? 'HIT!' : 'HIT!';
    if(ring.t>ring.dur+CFG.TOL_GOOD){ miss(); }
    // ボールはこちらへ近づく描写（軽く）
    if(!ball){ ball={x:ring.x, y:ring.y - innerHeight*0.22}; }
    ball.y = ring.y - innerHeight*(0.22*(1 - Math.min(1, prog)));
    ball.x += (ring.x - ball.x)*0.15;
  }
}

function draw(){
  g.clearRect(0,0,W,H);
  if(ball){
    const r = 8*DPR;
    g.fillStyle='#ffe07a';
    g.beginPath(); g.arc(ball.x*DPR, ball.y*DPR, r, 0, Math.PI*2); g.fill();
    g.strokeStyle='rgba(0,0,0,.35)'; g.lineWidth=1*DPR; g.stroke();
  }
}

addEventListener('pointerdown', tap, {passive:false});

/* ===== ポーズ＆メニュー ===== */
pauseBtn.addEventListener('click', ()=>{
  if(state!=='play'){ return; }
  state='pause';
  menu.classList.add('show');
  stopBGM(); // ミュートはここで好みで
});
resumeBtn.addEventListener('click', ()=>{
  menu.classList.remove('show');
  if(state==='pause'){
    state='play';
    last=performance.now();
    if(!RAF) RAF=requestAnimationFrame(loop);
    if(bgmOn) startBGM();
  }
});
restartBtn.addEventListener('click', ()=>{
  menu.classList.remove('show');
  resetAll();
});
bgmBtn.addEventListener('click', ()=>{
  if(bgmSeq){ stopBGM(); } else { startBGM(); }
});
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden && state==='play'){ pauseBtn.click(); }
});

/* ===== 中央ボタン ===== */
startBtn.addEventListener('click', ()=>{
  resetAll(); // 状態を綺麗に
  center.style.display='none';
  state='play';
  last=performance.now();
  RAF=requestAnimationFrame(loop);
  // 初回タップでAudioContextを起こす & BGMはデフォルトOFF
  AC.resume().catch(()=>{});
});

/* 初期化 */
updateHUD();
placeNextTarget();
draw();
</script>