<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PingTap — Retro Rally (tuned)</title>
<style>
  html,body{margin:0;height:100%;background:#0b1324;color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Noto Sans JP",sans-serif}
  #cv{position:fixed;inset:0;background:#0b1324;touch-action:none}
  .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;gap:12px;justify-content:space-between;pointer-events:none}
  .pill{min-width:160px;padding:10px 14px;border-radius:16px;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);font-weight:800}
  .card{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.55);text-align:center;padding:18px}
  .btn{margin-top:14px;padding:10px 18px;border:0;border-radius:12px;background:#ffd34d;color:#222;font-weight:800;box-shadow:0 4px 0 #caa132}
  .note{opacity:.85;margin-top:10px}
</style>

<canvas id="cv"></canvas>
<div class="hud">
  <div class="pill" id="sc">Score 0</div>
  <div class="pill" id="co">Combo 0</div>
  <div class="pill" id="be">Best 0 / Lv.1</div>
</div>

<div class="card" id="start">
  <div style="font-size:28px;margin-bottom:10px;font-weight:900">PingTap — Retro Rally</div>
  <div>背景は固定画像を読み込み（失敗時は自前描画でフォールバック）</div>
  <button class="btn" id="go">スタート</button>
  <div class="note">リングが縮んでベース円に重なったらTAP — ほどよい判定／テンポ良く加速</div>
</div>

<div class="card" id="over" style="display:none">
  <div id="final" style="font-size:20px;margin-bottom:8px">Score 0 / Best 0 / Lv.1</div>
  <button class="btn" id="retry">もう一回</button>
</div>

<script>
(()=>{
/* ===== 調整（今回のリクエスト反映） ===== */
const N=7;
/* 位置を全体的に上へ：ネットを高め＋自陣落下位置の下限を引き上げ */
const NET_Y_FIXED=0.56;          // ← 0.60 から上へ
const PLAYER_OFFSET=0.13;        // 自陣スポットをネットからどれだけ下に置くか（小さめで上寄せ）

/* 速くなるのを早めに＆伸び強め */
const START_DUR=1.45, SPEEDUP=0.90, MIN_DUR=0.52;

/* 判定をやや硬めに（以前より少しシビア） */
const RING_BASE=30, RING_SHRINK=32, MATCH_TOL=6.0, HIT_TOL=38;

/* その他 */
const BG_BRIGHTEN=0.10;

/* ===== DOM ===== */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const S=document.getElementById('start'), O=document.getElementById('over');
const GO=document.getElementById('go'), RY=document.getElementById('retry');
const SC=document.getElementById('sc'), CO=document.getElementById('co'), BE=document.getElementById('be'), FIN=document.getElementById('final');

/* ===== 小物 ===== */
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));

/* ===== レイアウト ===== */
let W=0,H=0,dpr=1, spotsTop=[], spotsBot=[];
function resize(){
  dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  layout();
}
function layout(){
  const net=H*NET_Y_FIXED;
  const yTop = clamp(net-18, 90, H-240);
  /* 自陣スポットは “あまり下に来ない” ように下限を引き上げる */
  let yBot = net + H*PLAYER_OFFSET;             // 以前より浅め
  const BOT_MAX = H-170;                         // 下側の上限（下がりすぎ防止）
  yBot = clamp(yBot, yTop+116, BOT_MAX);

  const margin=22, usable=W-margin*2-40;
  spotsTop=[]; spotsBot=[];
  for(let i=0;i<N;i++){
    const x=margin+20 + usable*(i+0.5)/N;
    spotsTop.push({x,y:yTop,r:22});
    spotsBot.push({x,y:yBot,r:22});
  }
}

/* ===== 背景 ===== */
let bgImg=null, bgLoaded=false;
(function loadBG(){
  const i=new Image();
  i.onload=()=>{ bgImg=i; bgLoaded=true; };
  i.onerror=()=>{ bgLoaded=false; };
  i.src='2FE72969-9374-4D85-ADBC-28EADEE8437A.png';
})();

/* ===== 状態 ===== */
let g=1400,pos={x:0,y:0},vel={x:0,y:0},phase='toPlayer',dur=START_DUR,t0=0;
let idxBot=3, idxTop=3;
let playing=false, score=0, combo=0, level=1;
let best=Number(localStorage.getItem('PT2_best')||0);
BE.textContent=`Best ${best|0} / Lv.${level}`;
let label=null, sparks=[], flash=0;

/* ===== SFX（軽いピンポン音） ===== */
let ac=null;
function ping(freq=1200, t=0.06){
  if(!ac) ac=new (window.AudioContext||window.webkitAudioContext)();
  const o=ac.createOscillator(), n=ac.createOscillator(), g=ac.createGain();
  o.type='square'; n.type='sine';
  o.frequency.value=freq; n.frequency.value=freq*2.1;
  g.gain.setValueAtTime(0.001, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.18, ac.currentTime+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+t);
  o.connect(g); n.connect(g); g.connect(ac.destination);
  o.start(); n.start(); o.stop(ac.currentTime+t); n.stop(ac.currentTime+t);
}

/* ===== 入力（デバウンス付き） ===== */
let tapLock=false;
cv.addEventListener('pointerdown', (e)=>{
  if(!playing || phase!=='toPlayer' || tapLock) return;
  tapLock=true; setTimeout(()=>tapLock=false,120);
  const r=cv.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;

  const s=spotsBot[idxBot];
  const dist=Math.hypot(x-s.x, y-s.y);
  const rr=ringRadiusNow();
  const diff=Math.abs(rr-RING_BASE);
  const onRadius = diff<=MATCH_TOL;
  const near = dist<=HIT_TOL;

  if(onRadius && near){
    const mult = (diff<=2.0)?3:(diff<=4.0)?2:1;
    combo++; score += 100*mult*(1+Math.floor((level-1)/2));
    SC.textContent=`Score ${score}`; CO.textContent=`Combo ${combo}`;
    label={text:(mult===3?'PERFECT!':mult===2?'GREAT!':'GOOD!'),x:s.x,y:s.y-38,a:1};
    sparkle(s.x,s.y); ping(1400,0.05);
    speedUp(); startLegToPaddle();
  }else{
    miss();
  }
},{passive:false});

/* ===== 演出 ===== */
function sparkle(x,y){ for(let i=0;i<12;i++){ sparks.push({x,y,vx:(Math.random()*2-1)*130,vy:(Math.random()*-1-0.2)*170,a:1,r:2+Math.random()*2}); } }
function drawSparks(dt){ const ns=[]; for(const s of sparks){ s.x+=s.vx*dt; s.y+=s.vy*dt; s.vy+=320*dt; s.a-=1.8*dt; if(s.a>0){ ns.push(s); ctx.globalAlpha=s.a; ctx.fillStyle='#ffe699'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,6.28); ctx.fill(); ctx.globalAlpha=1; } } sparks=ns; }
function drawLabel(dt){
  if(!label) return;
  label.y-=26*dt; label.a-=1.6*dt;
  if(label.a<=0){ label=null; return; }
  ctx.globalAlpha=label.a; ctx.fillStyle=(label.text==='PERFECT!')?'#ffec8a':'#aee1ff';
  ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.fillText(label.text,label.x,label.y); ctx.globalAlpha=1;
}

/* ===== 進行 ===== */
function ringRadiusNow(){ const now=performance.now()/1e3, left=Math.max(0,dur-(now-t0)); return RING_BASE + RING_SHRINK*(left/dur); }
function startLegToPlayer(){ 
  phase='toPlayer'; t0=performance.now()/1e3;
  /* 自陣の着弾は常に “上めの帯” に固定（yは spotsBot に統一、xのみランダム） */
  idxBot=Math.floor(Math.random()*N);
  const d=spotsBot[idxBot], Tm=dur; 
  vel.x=(d.x-pos.x)/Tm; vel.y=(d.y-pos.y-0.5*g*Tm*Tm)/Tm; 
}
function startLegToPaddle(){ 
  phase='toPaddle'; t0=performance.now()/1e3;
  /* 相手側は上段の帯にランダム */
  idxTop=Math.floor(Math.random()*N);
  const d=spotsTop[idxTop], Tm=dur; 
  vel.x=(d.x-pos.x)/Tm; vel.y=(d.y-pos.y-0.5*g*Tm*Tm)/Tm; 
}
function speedUp(){ 
  dur=Math.max(MIN_DUR, dur*SPEEDUP); 
  level=Math.min(10,1+Math.floor((START_DUR-dur)/(START_DUR-MIN_DUR+1e-9)*9)); 
  BE.textContent=`Best ${best|0} / Lv.${level}`; 
}
function miss(){ flash=1; ping(220,0.20); gameOver(); }

/* ===== ループ ===== */
let last=performance.now()/1e3;
function loop(){
  const now=performance.now()/1e3, dt=Math.min(.033, now-last); last=now;

  drawBG();
  if(playing){
    pos.x+=vel.x*dt; pos.y+=vel.y*dt + 0.5*g*dt*dt; vel.y+=g*dt;
    drawBall(pos.x,pos.y); drawSparks(dt); drawLabel(dt);

    // フェイルセーフ（画面外や過度に長い滞在で強制ミス）
    if(pos.y>H+140 || pos.x<-160 || pos.x>W+160) miss();
    if(now - t0 > dur + 0.9) miss();

    if(now - t0 >= dur - 0.01){
      if(phase==='toPlayer') miss();
      else { ping(900,0.06); startLegToPlayer(); }
    }
  }
  if(flash>0){ ctx.fillStyle=`rgba(255,0,0,${flash*0.25})`; ctx.fillRect(0,0,W,H); flash=Math.max(0,flash-0.05); }
  requestAnimationFrame(loop);
}

/* ===== 描画 ===== */
function drawBG(){
  if(bgLoaded && bgImg){
    const r=Math.max(W/bgImg.width, H/bgImg.height)*1.02;
    const w=bgImg.width*r, h=bgImg.height*r;
    const x=(W-w)/2, y=(H-h)/2;
    ctx.drawImage(bgImg,x,y,w,h);
    ctx.fillStyle=`rgba(255,255,255,${BG_BRIGHTEN})`; ctx.fillRect(0,0,W,H);
  }else{
    ctx.fillStyle='#0b1324'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#173259'; ctx.fillRect(W*0.05,H*0.52,W*0.90,H*0.28);
    ctx.fillStyle='#e9e2c4'; ctx.fillRect(W*0.495,H*0.52,4,H*0.28);
    ctx.fillRect(W*0.05,H*0.60,W*0.90,4);
    ctx.fillStyle='#0a0a0a'; ctx.fillRect(W*0.05,H*0.56,W*0.90,10);
  }
}
function drawBall(x,y){
  const isPlayer=(phase==='toPlayer'), trg=isPlayer?spotsBot[idxBot]:spotsTop[idxTop];
  const shadowY=trg.y, sh=Math.max(3,18-(shadowY-y)*0.03);
  ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,.25)'; ctx.ellipse(x, shadowY+6, sh, sh*0.5, 0, 0, 6.28); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='#ffe48a'; ctx.arc(x,y,7,0,6.28); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,.85)'; ctx.arc(x-2,y-2,2,0,6.28); ctx.fill();

  const rr=ringRadiusNow(), rx=trg.x, ry=trg.y;
  ctx.beginPath(); ctx.strokeStyle=isPlayer?'rgba(255,230,140,.95)':'rgba(160,210,255,.95)';
  ctx.lineWidth=3; ctx.arc(rx,ry,RING_BASE,0,6.28); ctx.stroke();
  ctx.beginPath(); ctx.setLineDash([4,4]); ctx.strokeStyle=isPlayer?'rgba(255,255,170,.95)':'rgba(180,230,255,.9)';
  ctx.lineWidth=3; ctx.arc(rx,ry,rr,0,6.28); ctx.stroke(); ctx.setLineDash([]);
  ctx.fillStyle=isPlayer?'rgba(255,230,120,.95)':'rgba(170,220,255,.95)';
  ctx.font='bold 14px system-ui'; ctx.textAlign='center'; ctx.fillText(isPlayer?'TAP!':'HIT!', rx, ry-RING_BASE-12);
}

/* ===== Start / Over ===== */
let bestKey='PT2_best';
function startGame(){
  playing=true; score=0; combo=0; level=1; dur=START_DUR;
  SC.textContent='Score 0'; CO.textContent='Combo 0'; BE.textContent=`Best ${best|0} / Lv.${level}`;
  S.style.display='none'; O.style.display='none';
  const net=H*NET_Y_FIXED;
  pos.x=W*0.5; pos.y=net-100;
  startLegToPlayer();
}
function gameOver(){
  playing=false;
  const newBest = Math.max(best|0, score|0);
  FIN.textContent=`Score ${score|0} / Best ${newBest} / Lv.${level}`;
  if(newBest !== (best|0)){ best=newBest; localStorage.setItem(bestKey,best); }
  BE.textContent=`Best ${best} / Lv.${level}`;
  O.style.display='flex';
}
GO.onclick=startGame;
RY.onclick=()=>{ S.style.display='flex'; O.style.display='none'; };

addEventListener('resize', resize);
resize(); layout(); requestAnimationFrame(loop);
})();
</script>